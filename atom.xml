<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mstn&#39;s blog</title>
  
  <subtitle>mstn@posteo.org</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mstn.github.io/"/>
  <updated>2019-07-26T14:09:51.365Z</updated>
  <id>http://mstn.github.io/</id>
  
  <author>
    <name>mstn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript for typeless people</title>
    <link href="http://mstn.github.io/2019/07/27/typescript-for-typeless-people/"/>
    <id>http://mstn.github.io/2019/07/27/typescript-for-typeless-people/</id>
    <published>2019-07-27T07:00:00.000Z</published>
    <updated>2019-07-26T14:09:51.365Z</updated>
    
    <content type="html"><![CDATA[<p>Typescript is becoming very popular. It is one of the ten most used languages on Github and its adoption has increased a lot in the past years (<a href="https://hackernoon.com/major-programming-trends-to-prepare-for-in-2019-169987cc75f4" target="_blank" rel="noopener">source</a>). The success of Typescript is in part due to the current trend in software engineering that rediscovered types. Strongly typeness and safety have become desirable properties of our programming languages to such a point that the terms are often used in an improper way, like marketing buzzwords, and types have acquired thaumaturgical qualities, like producing bug-free code or transforming frogs into 10x programmers.</p><h1 id="types-are-just-a-tool">Types are just a tool</h1><p>I am old enough to remember the times when types were considered harmful. Thus, I am very skeptic when people rediscover a technology or an idea.</p><p>Some common objections against types were and are:</p><ul><li>Types add overhead and reduce productivity.</li><li>There is no real case when you absolutely need them.</li></ul><p>I generally agree that these opinions are <em>sometimes</em> true.</p><p>I do not think that <em>any</em> silver-bullet can increase productivity. Software production is a complex process where several factors come into play and a single technology, methodology or tools are not enough to determine the fate of a project.</p><p>Actually, some tools can increase programming productivity. I think that it is &quot;scientifically&quot; proved that big screens can. If I have to choose between a big screen and a typed language, I will choose the former without any doubt. However, a tool is useful if you use it in the right way. If you sit on your monitor instead of watching it, it won't increase your productivity at all. You should also switch it on, at least I was told so.</p><p>Types are tools like big screens. However, they are more sophisticated than a monitor. This means that it could be difficult to find the right way to use them. And, on the other side, it is easier to be overwhelmed by them.</p><h1 id="to-type-or-not-to-type-thats-the-wrong-question">To type or not to type: that's the (wrong) question</h1><p>There is also a second aspect. What do we mean with &quot;types&quot;? How many different ways to use types in programming languages exist?</p><p>Programmers have a binary view of the world: good and bad, 0 and 1. When they evaluate a tool, they tend to manifest strong opinions (like me in this post maybe): &quot;it is crap&quot; or &quot;it is awesome&quot;. But life is usually more complex than that.</p><p>The real question is not &quot;to type or not to type&quot;. Types are not a binary feature of programming languages. It does not make sense to talk about typeful and typeless because it is not the case that a language can be with or without types.</p><p>All programming languages have a type system. But all type systems are different.</p><p>I think that the hostility against types has historical roots. Around 2008 people started to complain about types and the typeless revolution began. In my opinion, that was not a revolt against all type systems, but against Java. Java was the language taught in universities and used in industry. It came with the promise of a better world. In reality it carried to us only a heavy type system.</p><p>I did not like Java. I do not know if things improved over there. I am biased toward it and probably what I say is unfair. However, I think that some of the objections against types are objections against Java/C++/C# type systems. As such I agree with them.</p><p>Something similar happened in the database land. In the same years, people got fed up with the traditional databases, that is, SQL. A lot of new paradigms emerged. A few of them survived (e.g. MongoDB) with criticisms and we are rediscovering now that SQL was not that bad. In this case, in my opinion, the war was not against SQL in itself, but against the lack of tools. Do you remember Oracle and how easy was in comparison to work with MongoDB? If something good was left by the NoSQL revolution, it is more attention to the quality of tools for developers, from code editors to debugging tools and database user interfaces.</p><p>So, what about Typescript? It is not a magic wand, for sure. However, I believe that it can be useful in some contexts and when properly used. In addition, its type system has the flexibility and hackability of some dynamic languages. But hold on a minute and let me introduce some terminology.</p><h1 id="a-little-type-theory">A little type theory</h1><p>Here is a quick recap based on Wikipedia.</p><ul><li><strong>Type checking</strong> is the process of verifying type constraints</li><li><strong>Static type checking</strong> is type checking at compile time</li><li><strong>Dynamic type checking</strong> is type checking at runtime</li><li><strong>Strongly typed</strong> is an informal notion and means roughly &quot;how much I am allowed to violate type constraints&quot;. For example, if <code>x</code> is of type integer, it cannot be multiplied by <code>0.2</code> in a very strongly typed language because multiplication over floats is not allowed over integers.</li><li><strong>Explicit</strong> means that every variable must be typed.</li><li><strong>Implicit</strong> means that some types can be inferred by the compiler or interpreter.</li><li><strong>Safety</strong> is a property that Milner expressed as &quot;Well-typed programs cannot go wrong&quot;. In other words, if we can assign a type to an expression, we are sure that that expression can be evaluated without surprises.</li><li><strong>Inheritance</strong> is a <code>is-a</code> relation. Tom <code>is-a</code> cat, but Tom <code>is-a</code> an animal, too. There are at least two kinds of inheritance: structural and nominal. Nominal inheritance means that an item is labelled with its type: Tom <code>is-a</code> cat because I say it is a cat. Structural inheritance means that two items are the same if they share the same properties. Duck typing is a sort of structural inheritance. Here, we do not consider prototypical inheritance typical of Javascript.</li></ul><p>This is a table with some examples from some programming languages.</p><table><thead><tr class="header"><th></th><th>type checking</th><th>strong/weak</th><th>typing</th><th>safety</th><th>inheritance</th></tr></thead><tbody><tr class="odd"><td>Typescript</td><td>static/type guards</td><td>strong, but...</td><td>implicit</td><td>no</td><td>structural</td></tr><tr class="even"><td>Java</td><td>static/dynamic</td><td>strong</td><td>explicit</td><td>yes</td><td>nominal</td></tr><tr class="odd"><td>Ruby</td><td>dynamic</td><td>strong</td><td>?</td><td>NA</td><td>duck</td></tr><tr class="even"><td>Python</td><td>dynamic</td><td>strong</td><td>both (?)</td><td>NA</td><td>duck</td></tr><tr class="odd"><td>Javascript</td><td>dynamic</td><td>weak</td><td>NA</td><td>NA</td><td>NA</td></tr></tbody></table><p>Java has (had?) an explicit type system and is (was?) based on nominal inheritance. This means that every variable must be typed and hierarchies of classes and interfaces tend to emerge. In my opinion, for this reason Java type system is heavy and adds overhead. When you change a type, you have to chase all the type errors in the hierarchy. So you do not have to maintain your code base, but also your types.</p><h1 id="typescript-is-lightweight-if-used-wisely-imo">Typescript is lightweight, if used wisely (imo)</h1><p>Typescript is statically typed, but its type system is very different from Java's. In my opinion, it is closer to Ruby than Java!</p><ul><li>Structural inheritance is similar to duck typing (but a property must exist at compile time).</li><li>Typing is implicit and types can be inferred (but there is no run time check).</li><li>Type guards and disjoint unions allow us to emulate dynamic typing at run time.</li><li>Typescript intentionally sets a trade off between safety and developer productivity. So, it is ok to be unsafe.</li></ul><p>Typescript is implicit. You can assign a type to every variable like in the snippet below, if you enjoy it. But you do not have to. Typescript is able to infer the correct types.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> x: User = &#123; name: <span class="string">'Marco'</span> &#125;;</span><br></pre></td></tr></table></figure><p>Typescript interfaces have structural inheritance (but there is a proposal also for nominal). The following snippet of code compiles. Doesn't it look like duck typing?</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Dog&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> Duck&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cook</span>(<span class="params">d: Duck</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> spot: Dog = &#123;&#125;</span><br><span class="line">cook(spot)</span><br></pre></td></tr></table></figure><p>In Typescript there are classes and interfaces, but you do not have to build hierarchies. Flat data models are always better. In this way, you avoid premature and wrong abstractions</p><p>Typescript is strong as Ruby and Java, but it is a different flavor of being strongly typed. As a human being, you might know the run time type of an expression better than a dumb algorithm. It might depend on contextual information you have, which is not inferable from code. You can take advantage of your über-Turing powers to increase your productivity. You can show that AI has not won the war against humans with syntactic constructs like</p><ul><li><code>!</code> (“hey compiler, I am sure this is not <code>null</code>”)</li><li><code>as T</code> (“hey compiler, this is <code>T</code>”) (NB: it is not casting!)</li></ul><h1 id="where-typescript-is-useful">Where Typescript is useful</h1><p>If you build an SDK or library used by other applications, types are useful to define clear contracts between APIs and consumers. In addition, during refactoring, types can help you understand the consequences of a change.</p><p>Some types, common in functional programming languages, can help in everyday programming situations. For example,</p><ul><li><code>Option&lt;T&gt;</code> instead of <code>null</code> or <code>undefined</code> is better to describe a case when a function could return no value.</li><li><code>Either&lt;T, U&gt;</code> can replace <code>try-catch</code> blocks, which are usually hard to debug.</li><li><code>Task&lt;T&gt;</code> describes asynchronous computation and replaces <code>Promises</code>.</li></ul><p>For Typescript, <a href="https://github.com/gcanti/fp-ts" target="_blank" rel="noopener">fp-ts</a> is a very nice library that implements those types.</p><p>The considerations above are generic and not specific to Typescript. Typescript has also a couple of nice features that are worth mentioning.</p><p>Using <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener">mapped types</a> it is possible to define complex type constraints. For example, let us assume you want to implement a database of superheroes. Each hero has a list of super skills. For example, Superman has <code>flying</code> and <code>superStrength</code>, Aquamen has <code>fishTalking</code> and Batman has nothing. You can define a generic interface <code>Hero</code> where the skill set depends on a generic that defines which kind of hero the interface represents. For example, if <code>bruce</code> is a <code>Batman</code> hero, then Typescript knows that he cannot fly!</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Skills &#123;</span><br><span class="line">   Batman: &#123;&#125;;</span><br><span class="line">   Superman: &#123;</span><br><span class="line">       flying: <span class="literal">true</span>;</span><br><span class="line">       superStrength: <span class="literal">true</span>;</span><br><span class="line">   &#125;;</span><br><span class="line">   Aquaman:&#123;</span><br><span class="line">       fishTalking: <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> Hero&lt;T <span class="keyword">extends</span> keyof Skills&gt; &#123;</span><br><span class="line">   skills: Skills[T];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> clark: Hero&lt;<span class="string">'Superman'</span>&gt; = ...;</span><br><span class="line"><span class="keyword">const</span> bruce: Hero&lt;<span class="string">'Batman'</span>&gt; = ...;</span><br><span class="line"> </span><br><span class="line">clark.skills.flying; <span class="comment">// correct!</span></span><br><span class="line">bruce.skills.flying; <span class="comment">// type error!</span></span><br></pre></td></tr></table></figure><p>You can use this trick to document your code. I think that it is impossible to express this kind of constraints in <code>jsDoc</code>.</p><p>Type level operations are powerful in Typescript. Indeed, its type system is Turing complete. Look at <a href="https://github.com/tycho01/typical" target="_blank" rel="noopener">this project</a> for some very impressive examples.</p><p>I do not think that our goal is to type as much as we can. Typescript offers us a great flexibility and expressivity. It is up to us to decide how much typing we need. In the superheroes example, we can decide to define <code>Hero.skills</code> as a simple object. In this case, the compiler cannot help us to understand when, by mistake, we try to make <code>bruce</code> fly. I am not sure that <code>bruce</code> would agree, but it is fine. It is up to us to understand from the context what is more important: safety or productivity.</p><h1 id="when-typescript">When Typescript</h1><p>Typescript lets us decide what, if and how to type. As a general rule, I would say that we need to type at least the boundaries. The boundaries are the interfaces with the external world.</p><p>If a function is designed to be consumed by 3rd parties, it is better to type its arguments and return value.</p><p>If we use higher order components to compose functions, the units of composition and the combinators should be typed. In this way, Typescript helps us to compose things in a meaningful way.</p><p>Finally, we can use Typescript to follow a type-define-refine approach as proposed by <a href="https://www.manning.com/books/type-driven-development-with-idris" target="_blank" rel="noopener">Edwin Brady</a> for Idris.</p><ul><li>First, create a <strong>type</strong> describing what you want to achieve.</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstCommand: <span class="function">(<span class="params">input: Input</span>) =&gt;</span> Command = &#123;&#125; <span class="keyword">as</span> <span class="built_in">any</span></span><br></pre></td></tr></table></figure><ul><li>Then <strong>define</strong> a tentative implementation.</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstCommand: <span class="function">(<span class="params">input: Input</span>) =&gt;</span> Command =</span><br><span class="line"> input =&gt; input.payload.commands[<span class="number">0</span>]; <span class="comment">// type error command can be undefined</span></span><br></pre></td></tr></table></figure><ul><li>Finally, <strong>refine</strong> your implementation until type errors are resolved.</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstCommand: <span class="function">(<span class="params">input: Input</span>) =&gt;</span> Command =</span><br><span class="line"> input =&gt; input.payload.commands ? input.payload.commands[<span class="number">0</span>] : [];</span><br></pre></td></tr></table></figure><h1 id="where-typescript-is-bad">Where Typescript is bad</h1><p>Typescript is not the best programming language in the world. Other programming languages and different type systems could be more suitable in other contexts.</p><p>There are several things of Typescript I do not like.</p><p>For example, type errors look scary. In theory, Typescript team is working on a better notation. However, at the moment, error messages are quite long. Despite of that, they are very informative. If you read them carefully, you should be able to fix them easily.</p><p>Type level operations can be complicated and hacky. In real life, though, you can learn just the most common tricks, like mapped types. Even if it is interesting theoretically, you don't really need to implement <a href="https://github.com/Microsoft/TypeScript/issues/14833" target="_blank" rel="noopener">Turing machines</a> with Typescript types in your daily programming job.</p><p>Finally, Typescript is Javascript. You must know Javascript (and its oddities) to understand Typescript.</p><h1 id="conclusions">Conclusions</h1><ul><li>Types do not have thaumaturgical qualities, they are just a tool.</li><li>There aren't typeless and typeful languages, but many type systems.</li><li>Imo Typescript type system is lightweight, flexible and hackable.</li><li>Typescript has some useful features that help us in everyday programming.</li><li>We should not type as much as we can. It is more important to type the boundaries.</li><li>Typescript is not perfect.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Typescript is becoming very popular. It is one of the ten most used languages on Github and its adoption has increased a lot in the past 
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://mstn.github.io/tags/typescript/"/>
    
      <category term="type theory" scheme="http://mstn.github.io/tags/type-theory/"/>
    
      <category term="software engineering" scheme="http://mstn.github.io/tags/software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>Performance Evaluation and Refactoring</title>
    <link href="http://mstn.github.io/2019/07/25/performance-evaluation-and-refactoring/"/>
    <id>http://mstn.github.io/2019/07/25/performance-evaluation-and-refactoring/</id>
    <published>2019-07-25T07:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>Today, in order to offer an interactive user experience, web apps need a lot of client side code. Javascript is the most expensive resource in modern applications. The cost of Javascript, to paraphrase Addy Osmani [2], is low performances.</p><p>Our blazing fast shiny laptops crunch numbers easily. But Web developers are not a representative sample of the World population. So, even if our last web app works smoothly on my new laptop, it does not mean that my mom will have the same experience on her not-so-old tablet.</p><p>Performances affect user experience, user retention, conversion rates and revenues (you can read some real numbers here [1]). So worrying about performances is not &quot;premature optimization&quot;, but should be part of the everyday development cycle.</p><p>Google published some interesting notes about web and performances [1] with a lot of tools and suggestions to measure and improve them. You can find other examples on the same line on the web, for example, this [2] is a great case study analysis for the performances of the Walmart website. For a more detailed account, this [4] is a very valuable source, in particular if you are interested in understanding the inner workings of the Web as a platform.</p><p>A common misconception is that the only bottleneck is the network. However, even if our gzipped bundle is small for modern standards, this does not imply that users perceive a web app as fast. In fact, bundle size affects the “time to interaction”, too. So, even if gzipped transmission is fast, from a user’s perspective interaction could be still laggy and slow. The time from the point of view of users is not only the time to download the bundle, but also the time required to parse, boot and start event loop processing.</p><p>Addy Osmani gives a rule of thumb “350KB (gzipped) ~ 1MB ~ 14s until interactive”. He says that the ideal bundle size is &lt;200KB [2]. Surprisingly, this rule matches what I observed.</p><p>If we build a new web application, we should learn and follow performance best practices. However, if we work on a legacy application, life is not always that easy. The reason is that we are not always free to follow the best practices; sometimes we need to accept compromises because a change could be too expensive or break things. How can we understand what leads to the best result with the minimal effort?</p><p>In the rest of this post, I will talk about some strategies I adopted trying to improve performances for the webshop case study I introduced <a href="https://mstn.github.io/2019/02/24/two-phase-refactoring/">here</a>.</p><h1 id="a-case-study">A case study</h1><p>Let us consider, then, our webshop. In this case, the legacy Javascript is a bundle in the <code>head</code> section of the page. In theory, as from best practices, we could <code>defer</code> it, but it would not work in our case. Apparently, the legacy bundle is a dependency for some non-deferred code and seems to work only within <code>head</code> tags. In addition, we know that some css is changed by the bundle, dynamically. We want to run the css scripts before the page is rendered in order to avoid glitches.</p><p>The reality is that this legacy bundle is a blob of code that we do not fully understand. It is not safe to mark it with <code>defer</code> or move the <code>script</code> tag at the end of the body.</p><p>Fortunately, there is something we can do. Performance analysis gives us some hints about what to refactor first. It turns out that a few libraries are responsible for the most performance problems. So, if we focus only on them, we can introduce a big improvement with the least effort. The rest is just some code that we can leave untouched since performance optimization would not yield a big gain. (But there could be other reasons why we want to refactor it)</p><h1 id="performance-analysis">Performance Analysis</h1><p>In the rest of this section, I will show some data collected by <a href="https://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest</a> following [1]. I am sorry but I cannot share the original data. Moreover, tests are not reproducible and could have methodological flaws.</p><p>However, even if I would not take my tests too seriously, we can easily identify some low hanging fruits.</p><h2 id="high-parsing-and-loading-times">High parsing and loading times</h2><p>To get started we observe <code>DOMContentLoaded</code> and <code>load</code>. Today, <a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics" target="_blank" rel="noopener">other metrics</a> are considerated more accurate to measure user experience. However, the two old events can give us a ballpark figure.</p><div class="figure"><img src="/images/refactoring/P0.png" alt="Parsing document (dom content loading) and image loading (on load) for home page."><p class="caption">Parsing document (dom content loading) and image loading (on load) for home page.</p></div><div class="figure"><img src="/images/refactoring/P1.png" alt="Parsing document (dom content loading) and image loading (on load) for a product page."><p class="caption">Parsing document (dom content loading) and image loading (on load) for a product page.</p></div><h2 id="the-reasons-for-not-so-good-performances">The reasons for not so good performances</h2><div class="figure"><img src="/images/refactoring/P2.png" alt="Shares for home and product pages"><p class="caption">Shares for home and product pages</p></div><ul><li>~55% requests for images (it increases “on load event” time), but the image size is “small”.</li><li>1M (60%) for Javascript! This could be the reason of the high time for on dom content loaded event.</li><li>Javascript in <code>head</code> could block dom rendering since the browser implements a single-threaded model of execution.</li></ul><p>How this affects user experience</p><ul><li>Page is blank for a few seconds on low end devices.</li><li>Page is without images for a long time.</li><li>Users cannot interact with the web page immediately.</li></ul><h2 id="a-deeper-look">A deeper look</h2><div class="figure"><img src="/images/refactoring/P3.png" alt="Resource Usage (Chrome)"><p class="caption">Resource Usage (Chrome)</p></div><ul><li>1M legacy Javascript code</li><li>A lot of unused code (js/css) on a page</li></ul><h1 id="work-smarter-not-harder">Work smarter, not harder</h1><p>The quick analysis suggests us that lazy loading for images and trimming the legacy bundle could reduce the problems outlined above. For now, we focus only on the latter.</p><p>Since we cannot move the bundle or <code>defer</code> it, we can at least try to reduce its size. In this way, even if the bundle is still a render blocking resource, the time-to-render and the time-to-interaction should decrease.</p><p>The Pareto principle or 80/20 rule says that &quot;80% of the effects come from 20% of the causes&quot; [5]. It is a rule of thumb that works in many cases. Let's try to apply this law to our case.</p><p>Following the rule, the 20% of vendor libs should affect the 80% of bundle size. We have roughly 15 dependencies (1MB), 2 of them are ~80% of the total size. More or less, these are the numbers predicted by Pareto (bogus science works! ;P). The two libs are:</p><ul><li><code>chance.js</code> ~250KB</li><li><code>libphonenumber.js</code> ~530KB</li></ul><p>The two libraries take a lot of computing time with respect to the rest of the legacy bundle. This is the flamegraph from Chrome Dev Tools.</p><div class="figure"><img src="/images/refactoring/P8.png"></div><p>So, can we get rid of them?</p><p>First, we need to understand where the libs are used. We are lucky in this case because we can search for their occurrences in the code quite easily.</p><p>The first one, <code>chance.js</code>, is a collection of random generators. It is used in dev environment. So the first thought is that we can remove it from production. We can do even better. From a little code inspection, we find that we do not really need the library. So the actionable task is: remove <code>chance.js</code> dependency.</p><p>The second one, <code>libphonenumber.js</code>, is for phone number validation. It is used in a couple of forms and is huge because it is a <a href="https://www.npmjs.com/package/google-libphonenumber" target="_blank" rel="noopener">porting</a> of a library written in another programming language. There is a <a href="https://github.com/catamphetamine/libphonenumber-js" target="_blank" rel="noopener">lighter version</a>, but, in the QA process, we rely on the original Java library so we want to be 100% sure that we can validate the same phone number set. So, even if we will adopt the lighter version sooner or later, for now we have to stick with the bloated one.</p><p>It is safe to move the lib at the end of the <code>body</code> tag. The library is used only after DOM is rendered and users can interact with the page. We could also load the library lazily. In webpack is <a href="https://webpack.js.org/guides/lazy-loading/" target="_blank" rel="noopener">very easy</a>. But for now we choose to move the lib without any other improvement.</p><h1 id="measuring-the-improvement">Measuring the improvement</h1><p>I measured performances before and after the refactoring described in the previous section. Please take into account that other factors could have affected the change. In particular, several weeks passed between the first and the second measurement since the refactoring was not approved to production immediately. Thus, in those weeks, the webshop evolved. In few words, I did not prepare the tests in a sound way.</p><p>So let us take these numbers with a grain of salt. Images are screenshots from <a href="https://developers.google.com/web/tools/lighthouse/run" target="_blank" rel="noopener">Lighthouse</a> reports.</p><p><a href="https://developers.google.com/web/tools/lighthouse/run" target="_blank" rel="noopener">Lighthouse</a> gives us more user centric metrics than <a href="https://www.webpagetest.org/" target="_blank" rel="noopener">WebPageTest</a>.</p><p>Before refactoring (Emulated Nexus 5X, Simulated Slow 4G network)</p><div class="figure"><img src="/images/refactoring/P4.png"></div><p>After refactoring (Emulated Nexus 5X, Simulated Slow 4G network)</p><div class="figure"><img src="/images/refactoring/P5.png"></div><h1 id="how-vue-can-help-to-improve-performances">How Vue can help to improve performances</h1><p>We think that performances could benefit from Vue. In this section, I discuss some possible strategies and ideas.</p><h2 id="lazy-loading">Lazy loading</h2><p>Since the webshop has a lot of images, we could use Vue for lazy loading and controlling when content is displayed.</p><h2 id="optimistic-updates">Optimistic updates</h2><p>In the majority of cases, server responses are predictable while failures are rare. For example, if a user adds a product to basket, the result of this action will increase the number of items in the navbar shopping cart with high probability.</p><p>Hence, clients can guess the effect of a request on UI and UI can be updated accordingly before an actual response is back. When server responds, client initial guess is patched with the right behavior, if necessary. This kind of client updates are called optimistic updates for obvious reasons.</p><p>Optimistic updates are important to improve user experience because they reduce the perceived latency in client-server communication. Users do not see loading wheels, but they get an immediate response to their actions as if the app were running locally.</p><p>With Vue and VueX is easy to implement optimistic updates.</p><h2 id="but-vue-has-a-cost">But Vue has a cost</h2><p>As Javascript, even Vue has a cost. Vue is a complex framework which introduces some overhead. For example, a Vue instance parses HTML in order to find Vue components and build render functions (if we use <code>inline-template</code>s). If you look at a flamegraph of your page, you can actually measure this overhead.</p><div class="figure"><img src="/images/refactoring/P7.png"></div><p>As discussed in the previous <a href="https://mstn.github.io/2019/02/24/two-phase-refactoring/">post</a>, we had to create more Vue instances. Apparently (I am not 100% sure), from the picture above, Vue runs some parsing scripts for every instance. In the long run, we want to have just one instance. So this problem should disappear. It is ok to adopt a suboptimal solution during the first phase of a refactoring.</p><h1 id="webpack-optimizations">Webpack optimizations</h1><p>As part of the refactoring, we migrated from sprocket to webpack. Webpack is an excellent tool to understand how to reduce bundle sizes. Tools like <a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> help us to understand what there actually is in our bundle. Others like <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">tree-shaking</a> allow us to remove dead code.</p><h2 id="performance-budgets">Performance budgets</h2><p>While refactoring it is easy to break things. For this reason, we have regression tests. In a similar way, we need some guards to prevent us to degrade performances as a consequence of refactoring or new developments. The idea is that CI fails if assets are bigger than some thresholds. These thresholds are called performance budgets. Webpack has <a href="https://webpack.js.org/configuration/performance/" target="_blank" rel="noopener">tools</a> to help us define performance budgets integrated with our pipeline.</p><h2 id="take-care">Take care</h2><p>Adding a new library is easy. Fattening our bundle is much more. Thus, we should set performance budgets as first thing. Then, we should pay attention to libraries that could bloat our code base.</p><ul><li>Libraries designed for the server side, for example winston, tend to be bloated. We should not use them at all.</li><li>General purpose libraries, for example lodash, have a lot of features that we do not really need always. Webpacks has tools to trim unused features, see <a href="https://github.com/lodash/lodash-webpack-plugin" target="_blank" rel="noopener">lodash-webpack-plugin</a>. In my experience, you can half the relative weight of lodash using that plugin.</li><li>Validation libraries are useful, but are usually big. For example, <a href="https://baianat.github.io/vee-validate/concepts/bundle-size.html" target="_blank" rel="noopener">VeeValidate</a> is nice. If you need to validate only an email field, maybe two lines of Javascript are better than a full library.</li><li>Finally, we should <code>import</code> specific functions instead of full libraries. Again, webpack has tools to help us also in this case.</li></ul><h1 id="conclusion">Conclusion</h1><p>Takeaways</p><ul><li>Web performances are important. The network is not the only bottleneck. Bundle size affects also computing and rendering time.</li><li>Prioritize what you refactor depending on its impact on overall performances.</li><li>Sub-optimal solutions are acceptable during refactoring.</li><li>Performances are in the eye of the users. So techniques (lazy loading, optimistic updates) to reduce the perceived latency in client-server communication are important.</li><li>Frameworks and libraries have a cost.</li><li>Set performance budgets to avoid performance regressions.</li><li>Invest in the right tools, e.g. webpack.</li></ul><h1 id="references">References</h1><p>[1] Google, <a href="https://developers.google.com/web/fundamentals/performance" target="_blank" rel="noopener">Web Fundamentals: performance</a></p><p>[2] Ivan Akulov, <a href="https://iamakulov.com/notes/walmart/" target="_blank" rel="noopener">Case study: analyzing the Walmart site performance</a>, 2018</p><p>[3] Addy Osmani, <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4" target="_blank" rel="noopener">The cost of Javascript in 2018</a>, 2018</p><p>[4] Ilya Grigorik, <a href="https://hpbn.co/" target="_blank" rel="noopener">High Performance Browser Networking</a></p><p>[5] https://en.wikipedia.org/wiki/Pareto_principle</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today, in order to offer an interactive user experience, web apps need a lot of client side code. Javascript is the most expensive resour
      
    
    </summary>
    
    
      <category term="performance" scheme="http://mstn.github.io/tags/performance/"/>
    
      <category term="web" scheme="http://mstn.github.io/tags/web/"/>
    
      <category term="vue" scheme="http://mstn.github.io/tags/vue/"/>
    
      <category term="rails" scheme="http://mstn.github.io/tags/rails/"/>
    
      <category term="refactoring" scheme="http://mstn.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>Two phase refactoring</title>
    <link href="http://mstn.github.io/2019/02/24/two-phase-refactoring/"/>
    <id>http://mstn.github.io/2019/02/24/two-phase-refactoring/</id>
    <published>2019-02-24T08:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>Front end development has been changed a lot in the past decade.</p><p>Not only frameworks have changed. The Web itself is now a very different place respect to ten years ago. Browsers are more powerful, we can compute a lot of stuff on the client side. Mobile is a reality. Users expect more advanced fluid interactions with web applications.</p><p>Nevertheless, many existing web applications are still tightly bound to old technologies and approaches, in particular on the client side.</p><p>Upgrading your stack is not just a matter to follow the current hype. A modern technology can give also real benefits. In particular, it could impact on user satisfaction, performances, conversion rates and Google ranking. This means more profits and more money for many companies.</p><p>The engineering saying &quot;if it works, don't change it&quot; is probably the main reason to resist to change. Indeed, the cost of a full rewrite is too high and too risky. For example, many business rules are wired into the legacy code. Moreover, we should understand how to leverage the existing assets and team expertise/skill sets more than distrupting the current state of things.</p><p>Hence, when we approach a legacy system to introduce a new technology, we need to incrementally refactor the existing code base. In a first phase, we need to prepare the code base to change and, only after that, we can apply changes. I call this process &quot;two-phase refactoring&quot;.</p><p>In the rest of this post, I will discuss what two-phase refactoring is with some examples from a project I have worked on lately. We discuss a case study where we want to migrate a legacy Rails app to Vue on the client side. We show how Vue can be adopted incrementally and how it can be a good fit for a two-phase refactoring.</p><h1 id="two-phase-refactoring">Two Phase Refactoring</h1><p>Martin Folwer, in his famous book [1], defines refactoring as a process where code is changed in small steps that leave functionalities unchanged. He focuses on the description of syntactic techninques, which should help to indentify and reduce bad smells, that is, possibly problematic pieces of code.</p><p>While introducing a new technology, the techniques we need to apply are similar to Fowler's ones. However, we are not simply transforming the existing code base to improve some code metric. We are replacing part of the stack with another one. New technologies can be foundamentally different in many different aspects. For example, <code>jQuery</code> is imperative while <code>Vue</code> is declarative and compositional.</p><p>Hence, introducing a new technology is harder than traditional refactoring.</p><p>A new technology cannot be just dropped there. Migration should be approached in two ideal phases.</p><p>The first phase of refactoring consists of reorganizing the code, without altering functionalities, in such a way to make the transition possible. The second phase is implementing the transition.</p><p>For example, consider the scenario where server interactions are handled by functions bound to html events (e.g. <code>&lt;a onClick=...&gt;</code>) and implemented with <code>jQuery.ajax</code> calls. In order to decouple presentation from network layer and model, we want to bind &quot;actions&quot; to dom and delegate the actual communication to another component. We would like to get rid of <code>jQuery</code>, too. There are faster alternatives with smaller footprints. However, the legacy code might be very entangled with <code>jQuery</code> and so we cannot remove it in a small simple step. What we can do is to extract and move the <code>jQuery</code> logic to some methods (like in Fowler's &quot;extract method&quot; technique). We do not change the underlying communication mechanism, but the first refactoring step enables us to prepare the code for a better solution.</p><h1 id="refactoring-and-tests">Refactoring and tests</h1><p>Solid tests are a pre-requisite for any sort of refactoring. However, a good test suite is not enough when we migrate to a new technology. Even when feature test coverage is good, every change should be pass through (manual) QA.</p><p>For example, in the example above, if we remove <code>jQuery</code> in one shot, several features are affected at the same time. Instead, if we firstly extract methods, we can pass changes through QA because they are feature based.</p><h1 id="whenwhat-you-should-not-refactor">When/what you should not refactor</h1><p>There is no need to refactor all the legacy code. We do not want to change things that has been worked for a so long time. Old and new technologies can often co-exist without too much overhead. Thus, when it is possible, we can leave the legacy code untouched.</p><h1 id="a-case-study">A case study</h1><p>This case study is based on some real working experience.</p><p>Assume we want to refactor a webshop visited by thousands of users. The stack is Ruby on Rails with some unstructured jQuery on the client side.</p><p>We do not want to rewrite the whole application. It is too impractical since the code base is very large. Moreover, the team has a great expertise in Rails programming. So we want to leverage the existing assets more than turning the app upside down.</p><p>The main problem is to avoid business logic duplication. Business logic is codified on the server side. We do not want to duplicate logic on the client because it would be hard to maintain. In addition many business rules are tacit and encoded in software.</p><p>Since the team has developed a lot of expertise with Rails rendering, we stick to Rails as a rendering engine. We want to render HTML on the server, mainly for SEO reasons. However, although Rails can render Vue components on server side (e.g. <a href="https://github.com/samtgarson/vueport" target="_blank" rel="noopener">vueport</a>), it does not make sense to ask the team to learn something different.</p><p>Finally, we want to adopt Vue incrementally. Vue and the legacy Javascript code should co-exist for a while. The main reason is that we want to release new features implemented with Vue as soon as possible. We do not want to wait to replace the legacy code with something else before publishing the outcome of the refactoring.</p><h2 id="vue-vs-react-vs-something-else">Vue vs React vs Something else</h2><p>The choice of Vue is made after some considerations. To sum up, Vue seems more flexible than its direct competitor, that is, React.</p><p>We need to bind components to pre-rendered DOMs. It is easier to bind Vue components to existing DOM elements. React-based alternatives are <a href="https://github.com/facebook/react/issues/7712#issuecomment-360599550" target="_blank" rel="noopener">not robust enough</a>.</p><p>We do not have to stick to a single template language, i.e. JSX. Although it is possible to use <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">React without JSX</a>, Vue is much more flexible and easy to use with different template languages.</p><p>We could have considered other technologies, such as <a href="https://github.com/stimulusjs/stimulus" target="_blank" rel="noopener">stimulus.js</a>. Stimulus is quite popular in Rails community and it is a good tool. Nevertheless, we opt for Vue because it should scale better for larger projects. We do not want only to make some html smarter, but also to implement some serious inter-component communication. Vue seems more mature and complete on this front.</p><h2 id="vue-instances">Vue instances</h2><p>In order to reduce the risk of breaking things, we want to start Vue only when is strictly necessary. Vue instances could be a way to restrict and control which regions are affected by the refactoring.</p><p>The first phase of refactoring consists of identifying which regions we are going to change. In the second phase, we can move towards a single Vue instance for the whole application, as it is common. However, having - firstly - more instances allow us to disable Vue for page sections without Vue templates.</p><p>For example, a legacy carousel component has problems with Vue because of some embedded Javascript code. Carousel instances are ubiquitous in the web application. We build a Vue version of the carousel component and we enable it page by page after careful testing.</p><h2 id="inline-templates">Inline templates</h2><p>In order to keep rendering performed by Ruby on server, we use <code>inline-template</code>s and attach logic to existing html with Vue.</p><p>In this way, we can use <code>props</code> to pass data from Ruby to Javascript (a well-known technique) and still use Ruby for <code>i18n</code>, rendering and business logic.</p><p>We know that <code>inline-template</code>s could have <a href="https://vuejs.org/v2/guide/components.html#DOM-Template-Parsing-Caveats" target="_blank" rel="noopener">some parsing caveats</a>. Thus, <code>inline-template</code> are not the best solution.</p><p>However, the legacy app is not organized in components. With <code>inline-template</code>, we can start to identify some common html patterns as component candidates. So marking existing html with <code>inline-template</code> could be the first step in a two-step refactoring that enables the migration toward a more compositional UI architecture.</p><h2 id="vue-components-as-jquery-wrappers">Vue components as jQuery wrappers</h2><p>We can wrap existing <code>jQuery</code> into Vue components. There is no need to rewrite <code>jQuery</code> logic from scratch in the first phase. However, we can isolate <code>jQuery</code> in Vue lifecycles. For example, let us assume we have a phone number validator base on <code>jquery.validate</code>. In the long term, we want to get rid of <code>jquery.validate</code> and the phone validation library. However, for now we need to keep them.</p><p>The first phase is to isolate this legacy code in a Vue component, let's say, <code>&lt;with-legacy-phone-validation/&gt;</code>. The new component lifecycle methods bind and unbind jQuery events (see for example <a href="https://www.smashingmagazine.com/2018/02/jquery-vue-javascript/" target="_blank" rel="noopener">this tutorial</a>). The old code can be copied &quot;almost&quot; verbatim.</p><p>In this way, we have identified which parts are affected by the old validation. It would be easier to remove <code>jquery.validate</code> in a second phase.</p><h2 id="vuex">VueX</h2><p>In order to avoid business logic duplication, the client state should be created and updated by the server following business rules. In this way, the client does not have to know any business logic.</p><p>Since we need a global state on the client, VueX is the most natural tool to choose to handle client state.</p><p>Another benefit of VueX is the possibility to pre-fetch client state. In other words, a <code>script</code> tag with some <code>json</code> is injected in the body of an html page. Some javascript fetches this <code>json</code> and initializes the state.</p><p>The technique is often used to save a client-server round trip and for server side rendering. In this context, it is used also as another way to pass information from Ruby to Javascript without using <code>props</code>.</p><p>Passing data via <code>props</code> is simple and is the right things to do in many cases. However, it is not suitable if data are not just string, but have types like <code>json</code> or <code>number</code>. In this case a component should parse the data and it could be quite cumbersome to see.</p><h2 id="listening-to-dom-changes">Listening to DOM changes</h2><p>The legacy code can change DOM in two ways. The first one is using <code>jQuery</code>, but this usually works quite well with Vue. The second is through server responses.</p><p>For historical reasons, dynamic client behavior is implemented with server ajax calls returning a javascript code to be executed on the client. For example, when an item is added to basket, the server returns some javascript to update the basket counter.</p><p>Of course, this technique is not very nice because it violates the &quot;separation of concerns&quot; principle. As part of the refactoring we want to move from this approach to a more clean data-only API way. However, since we want to adopt Vue incrementally, we have to cope with this.</p><p>The main problem is that javascript updates could destroy Vue instances. The solution is to listen to dom changes and recreate Vue instances if they are destroyed. Technically, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">W3C Mutation API</a>, which are supported by all browsers today.</p><p>The limitation of this approach is that it does not work for arbitrary dom changes. For example, a Javascript update could destroy the DOM listener! So we must hope that the Rails app is designed in a smart way so that Javascript updates always and only occur for the same portion of the HTML page.</p><h1 id="conclusion">Conclusion</h1><p>Introducing a new technology in a legacy app is challenging. The new technology cannot be just dropped into the existing code.</p><p>We should approach refactoring in two macro phases. First, we need to prepare the code to migration and then implement the migration. The first phases should consist of small QAable/feature based steps.</p><p>We discussed some examples from a case study where we want to add Vue to a legacy Rails app.</p><p>Vue is good for this end since it can be incrementally adopted and fits well into a two-phase refactoring.</p><h1 id="acknowledgements">Acknowledgements</h1><p>Many thanks to the team at <a href="https://purepoint.io/" target="_blank" rel="noopener">Purepoint</a>. I learnt a lot from discussions and criticisms. This blog post has been adapted from some internal documents I prepared.</p><h1 id="references">References</h1><p>[1] Martin Fowler, Refactoring: Improving the Design of Existing Code, 1999</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Front end development has been changed a lot in the past decade.&lt;/p&gt;
&lt;p&gt;Not only frameworks have changed. The Web itself is now a very di
      
    
    </summary>
    
    
      <category term="web" scheme="http://mstn.github.io/tags/web/"/>
    
      <category term="vue" scheme="http://mstn.github.io/tags/vue/"/>
    
      <category term="rails" scheme="http://mstn.github.io/tags/rails/"/>
    
      <category term="refactoring" scheme="http://mstn.github.io/tags/refactoring/"/>
    
      <category term="jquery" scheme="http://mstn.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Sketching a language for Web Programming (Part II)</title>
    <link href="http://mstn.github.io/2018/12/02/sketching-a-language-for-web-2/"/>
    <id>http://mstn.github.io/2018/12/02/sketching-a-language-for-web-2/</id>
    <published>2018-12-02T08:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>This is the second episode of my ramblings about web programming I started <a href="/2018/11/06/sketching-a-language-for-web/">here</a>.</p><p>Previously, I sketched a sort of graphical language to define user interfaces and their dynamics. The work is inspired by Milner's bigraphs [1] and the final goal is to come up with an operational semantics in the style of signal flow graphs [2] or a new web framework or both.</p><p>Here, I want to jot down some notes about composition.</p><p>In this post I will introduce new concepts. I ask to forgive me in advance if my treatment is still quite vague and inaccurate. The aim of these notes is to refine my own intuition before working on a more formal approach.</p><h1 id="components">Components</h1><p>A component <span class="math inline">\(F\)</span> is a &quot;data structure&quot; with a type <span class="math inline">\(A \to B\)</span>. The type <span class="math inline">\(A \to B\)</span> consists of two other types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Think about types as interfaces that help us to compose components together.</p><p>If you know a bit of Category Theory, you should see that a component is a morphism. What is a morphism? First, it is not a function. Not necessarily at least. A morphism is like a Lego brick. A Lego brick is a shape with two interfaces (bottom side and top side). Interfaces can have different types <span class="math inline">\(2 \times 4\)</span>-bottom or <span class="math inline">\(2 \times 4\)</span>-top (e.g. the brick sizes). We can put together Lego bricks if their interfaces match. That is all you need to know for now.</p><div class="figure"><img src="/images/web-2/lego.jpg" alt="From Wikimedia. A component/morphism is a Lego brick with two connecting interfaces."><p class="caption">From <a href="https://commons.wikimedia.org/wiki/File:Klocek_LEGO_1.jpg" target="_blank" rel="noopener">Wikimedia</a>. A component/morphism is a Lego brick with two connecting interfaces.</p></div><p>As I discussed in my previous post, we can see a web application in two independent ways: a spatial part (dom) and a dynamic part (communication or data dependencies). Hence, it can be represented by two data structures.</p><p>The spatial part is represented as a tree. Trees have interfaces we call roots and sites. Intuitively, we can compose two trees plugging roots into sites.</p><p>In React components have only one root (i.e. the output of the <code>render</code> function), but it is convenient to define components as a collection of trees, each with its own root. Sites are similar to the concept of <code>slot</code> in Vue or even <code>children</code> prop in React. So we are not inventing anything new.</p><p>The dynamic part connects dom elements to states and defines a sort of dependency graph. When a state changes, we expect some updates in UI elements. React and Vue implement inter-component communication using the Flux pattern or, in general, the programmer defines the mechanism behind state change. Here, we do not want to say how state changes, but what changes. It could be closer to MobX or transparent reactivity in Meteor.</p><p>So, more precisely, a component <span class="math inline">\(F\)</span> has type <span class="math inline">\((n, X) \to (m, Y)\)</span> where <span class="math inline">\(n, m \in \mathbb{N}\)</span> and <span class="math inline">\(X, Y\)</span> are finite sets of names. Intuitively, <span class="math inline">\(F\)</span> is a piece of user interface with <span class="math inline">\(n\)</span> sites and <span class="math inline">\(m\)</span> roots. It has an outer interface <span class="math inline">\(Y\)</span> and an inner interface <span class="math inline">\(X\)</span>. Definitions and terminology are from bigraphs, as usual.</p><p>Internally, <span class="math inline">\(F\)</span> is represented with two data structures: a tree-like structure for the dom hierarchy and some linking between node ports for communication. The picture below shows a generic component with type <span class="math inline">\((2, \{ x \}) \to (1, \{ y \})\)</span>.</p><div class="figure"><img src="/images/web-2/generic-component.png"></div><h2 id="a-simple-stateless-button">A simple stateless button</h2><p>Let's consider a button <span class="math inline">\(B_0: (0, \emptyset) \to (1, \{ \mathit{event}, \mathit{handle} \})\)</span>.</p><div class="figure"><img src="/images/web-2/button-0.png"></div><p>A button is a single dom element and can be plugged into an available slot in a larger context. So it has one root and no holes. For example, we can put a button inside a <code>div</code> element. A button has an outer interface with two elements to communicate with the world: <span class="math inline">\(\mathit{event}\)</span> and <span class="math inline">\(\mathit{handle}\)</span>.</p><p>Intuitively, <span class="math inline">\(\mathit{event}\)</span> listens to dom events whereas <span class="math inline">\(\mathit{handle}\)</span> triggers a response to a dom event. However, a button is not a function, but a relation between events and handlers. We will see it when we discuss operational rules.</p><h2 id="components-are-views-plus-states">Components are views plus states</h2><p>A component is not only a view like in the case of <span class="math inline">\(B_0\)</span>. For example, we can define a counter button <span class="math inline">\(B_1: (0, \{ \mathit{count} \}) \to (1, \{ \mathit{event} \})\)</span> that emits an increasing sequence of numbers at each click. We need an internal state to store the number of clicks. We use the <code>inc</code> state we introduced <a href="/2018/11/06/sketching-a-language-for-web/">here</a>.</p><div class="figure"><img src="/images/web-2/button-1.png"></div><p>In this case, the main difference is that <span class="math inline">\(B_1\)</span> has a non empty inner interface <span class="math inline">\(\{ \mathit{count} \}\)</span>. This means that <span class="math inline">\(\mathit{count}\)</span> depends on a state defined in component <span class="math inline">\(B_1\)</span> or in its context. On the contrary <span class="math inline">\(\mathit{event}\)</span> depends on the outer context (for example, the actual dom).</p><h2 id="components-are-cross-functional-features">Components are cross-functional features</h2><p>Microfrontends is an emerging trend in web development [3]. In this paradigm, a component, i.e. the unit of composition, is a cross functional feature. This is different from React and other frameworks where components are smart chunks of HTML; they implements a functionality (e.g. the navbar basket), not a use case (e.g. I want to purchase a fuzzy cat).</p><p>For example, in a web shop, Team F can implement use case &quot;add to basket&quot; as a component <span class="math inline">\(F: (0, \emptyset) \to (2, \{ \mathit{product} \})\)</span> while Team G works on <span class="math inline">\(G: (2, \{ \mathit{product} \}) \to (1, \emptyset \})\)</span> component for use case &quot;show product&quot;.</p><div class="figure"><img src="/images/web-2/webshop.png"></div><p>Team F and Team G work independently. In particular, Team F provides all the logic needed to implement the use case &quot;add to basket&quot;. The same component <span class="math inline">\(F\)</span> with its views and states can be reused in a context different from <span class="math inline">\(G\)</span>, for example, if we want to add an additional purchasing option in the checkout page.</p><p>We do not give a full description of the two states and their rules here, because we want to focus only on composition now. We leave to the reader the not so hard task.</p><h2 id="components-are-black-boxes">Components are black boxes</h2><p>In the above picture the product component does not show all the details of its implementation. Components are black boxes and they interact only through thier interfaces. For this reason, even if it might look complicated to draw lines from states to views and back, we do not have to see all the wiring in practice.</p><p>In other words, we can zoom in and out depending on the level of abstraction we are interested in. The min zoom level is the whole application. An application is just another component. Instead the max zoom level is a button or a more complex component. We can work on sub-components without worrying about the context.</p><p>In my opinion, React does not reach this level of compositionality. Quite the contrary. Sometimes state information leaks from components and it is hard to move components around without changing their implementation, in particular their states.</p><p>Zooming concept is similar to CycleJS &quot;fractal&quot; property. Actually, I rather have in mind [4] (spotted many years ago on some CT blog (Baez?)). I will write about CycleJS sooner or later.</p><h1 id="composition">Composition</h1><p>In React types are used to specify the shape of <code>props</code>. In other words, types tell us if we invoke <code>render</code> functions with the proper values as arguments. Moreover, we can verify (only at run time) if a component has just one child.</p><p>In general, however, types can be more powerful. They can help us to compose components in such a way that we are a bit more certain that the whole web application behaves as expected.</p><p>For example, we want to be sure that a parent component takes the correct number of children or that a component's dependencies are provided by the context where it is plugged in. These checks should be at compile time. In other words, we use types to guide the composition of components in a web application.</p><p>Let's see how composition is defined for dom elements and dependencies. This is more or less the basic idea of Milner's bigraphs. As for bigraphs, the two faces of web applications share the similar algebraic/compositional properties (i.e. they are related to symmetric monoidal categories).</p><h2 id="dom-composition">Dom composition</h2><p>Dom is a hierarchy of nested elements. It defines &quot;within&quot;-relations between HTML tags and custom elements. We have two ways to compose dom elements: inserting one element into another (e.g. parent/child) or juxtaposing them (e.g. siblings).</p><div class="figure"><img src="/images/web-2/dom-composition.png"></div><p>The picture above explains this concept. Dashed lines and gray boxes represent roots and sites, respectively. Composition <span class="math inline">\(G \circ F\)</span> is defined if <span class="math inline">\(G\)</span> and <span class="math inline">\(F\)</span> interfaces match.</p><p>Milner defines a data structure, i.e. place graphs, to describe this scenario and proves that place graphs are morphims in a sort of symmetric monoidal category (it is a bit more complex than this!). In this category nesting is morphism composition <span class="math inline">\(\circ\)</span> while juxtaposition is tensor product <span class="math inline">\(\otimes\)</span>.</p><h2 id="dependency-composition">Dependency composition</h2><p>In the previous section, we saw two ways to dispose components. There are other two ways: left/right and top/bottom.</p><div class="figure"><img src="/images/web-2/dep-composition.png"></div><p>Above, we show the two ways to compose two components. Top and bottom sides are labeled with finite set of names for interfaces. Composition <span class="math inline">\(G \circ F\)</span> is defined only if interfaces match.</p><p>In bigraph, link graphs are the data structures that represent dependencies. Again link graphs are mortphims in a sort of symmetric monoidal category (and again, it is a bit more complex than this!). In this category top/bottom composition is morphism composition <span class="math inline">\(\circ\)</span> while right/left composition is tensor product <span class="math inline">\(\otimes\)</span>.</p><p>Let's go back to our example. Button <span class="math inline">\(B_1\)</span> can be obtained by composition of button <span class="math inline">\(B_0\)</span> with a state-only component. This is common in web programming. <span class="math inline">\(B_0\)</span> does not define what happens on click event, we need to bind the event with a function handler. Since we want to have generic reusable buttons, the handler logic is not part of the button definition. In the picture below we show how to build <span class="math inline">\(B_1\)</span> from simpler components. Note that composition is possible if inner and outer interfaces &quot;match&quot;. In this case we need to use two identity components.</p><div class="figure"><img src="/images/web-2/button-composition.png"></div><h1 id="building-a-counter">Building a counter</h1><p>Finally, let's try to put everything together and build a simplified version of the counter introduced <a href="/2018/11/06/sketching-a-language-for-web/">here</a>. Dotted boxes highlight basic blocks and we label links with outer/inner names. It should be clear how the full counter can be built from basic blocks using composition and tensor product for the two dimensions, namely, dependency and dom graphs.</p><div class="figure"><img src="/images/web-2/counter.png"></div><p>Now, we can give a sample of operational derivation following the structure of the component. We follow [2]. Please, note that this is still tentative and many details must be clarified. What I want to sketch here is how we can describe the behavior of a simple web application from simple rules.</p><p>The derivation below is read top-down. Horizonal lines mean &quot;deduction&quot;. From transitions for basic blocks we derive a transition for the whole application following the application's structure. For this reason, we talk about <em>structural</em> operational semantics. Two transitions for two sub components can be composed if their interfaces match. In this simple example, this happens when the same labels (in red) are assigned to the two components.</p><div class="figure"><img src="/images/web-2/sos.png"></div><h1 id="coming-soon">Coming soon</h1><p>We have seen that bigraphs are three dimentional data structures, since we can define in/out, left/right, top/bottom spatial relations. I am going to introduce a forth dimension: a component can be in front of or behind another component. This dimension is independent from the other three (left/right, top/bottom, in/out).</p><p>I feel that this is needed to define the behavior of IF blocks. In other words, if a component <span class="math inline">\(A\)</span> is on another component <span class="math inline">\(B\)</span>, <span class="math inline">\(B\)</span> transitions are hidden or disabled. In bigraphs morphisms can be active or passive. This is a similar idea. However, I would like to experiment what happens if activity does not depend on nesting (as in bigraphs), but it is an independent dimention.</p><p>Hence, if I am able to define this new concept, we need to think in four dimensions in order to build a web application. It is not surprising that front end programming is complex. ;)</p><h1 id="other-episodes">Other episodes</h1><ul><li><a href="/2018/11/06/sketching-a-language-for-web/">Sketching a language for Web Programming (Part I)</a>.</li></ul><h1 id="credits">Credits</h1><p>Diagrams in this post are created using <a href="https://www.mathcha.io" target="_blank" rel="noopener">Mathcha</a>.</p><p>Cat clipart from <a href="http://www.publicdomainfiles.com/show_file.php?id=13488686412382" target="_blank" rel="noopener">here</a>.</p><p>Lego brick from <a href="https://commons.wikimedia.org/wiki/File:Klocek_LEGO_1.jpg" target="_blank" rel="noopener">Wikimedia</a>.</p><h1 id="references">References</h1><p>[1] Robin Milner. The space and motion of communicating agents. Cambridge University Press, 2009.</p><p>[2] F. Bonchi, P. Sobocinski, and F. Zanasi. Full abstraction for signal flow graphs. ACM SIGPLAN Notices. Vol. 50. No. 1. ACM, 2015.</p><p>[3] M. Geers, <a href="https://micro-frontends.org/" target="_blank" rel="noopener">Microfrontends</a>, 2016(?)-2018</p><p>[4] J.C. Willems. The behavioral approach to open and interconnected systems. IEEE Control Systems 27.6 (2007): 46-99.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is the second episode of my ramblings about web programming I started &lt;a href=&quot;/2018/11/06/sketching-a-language-for-web/&quot;&gt;here&lt;/a&gt;.&lt;
      
    
    </summary>
    
    
      <category term="react" scheme="http://mstn.github.io/tags/react/"/>
    
      <category term="web" scheme="http://mstn.github.io/tags/web/"/>
    
      <category term="vue" scheme="http://mstn.github.io/tags/vue/"/>
    
      <category term="bigraphs" scheme="http://mstn.github.io/tags/bigraphs/"/>
    
      <category term="signal flow graphs" scheme="http://mstn.github.io/tags/signal-flow-graphs/"/>
    
      <category term="category theory" scheme="http://mstn.github.io/tags/category-theory/"/>
    
      <category term="composition" scheme="http://mstn.github.io/tags/composition/"/>
    
      <category term="cyclejs" scheme="http://mstn.github.io/tags/cyclejs/"/>
    
  </entry>
  
  <entry>
    <title>Sketching a language for Web Programming</title>
    <link href="http://mstn.github.io/2018/11/06/sketching-a-language-for-web/"/>
    <id>http://mstn.github.io/2018/11/06/sketching-a-language-for-web/</id>
    <published>2018-11-06T08:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.579Z</updated>
    
    <content type="html"><![CDATA[<p>In this post I want to talk about a language for representing user interfaces and their dynamics. At the moment, the language is only sketched and I would like to present the basic idea even if it is nothing but an idea.</p><p>My background is from React and Vue. So this post is influenced by them, in a positive and in a negative way. I do not know Elm, but I feel there are some similarities with what I am writing here, in particular the idea of decoupling views from updates.</p><p>The brief summary outlined below does not pretend to be complete nor accurate. Rather, I want to highlight the main points I would like to tackle with my language proposal.</p><h1 id="an-opinionated-inaccurate-view">An opinionated inaccurate view</h1><p>Over the past years several frameworks and programming paradigms have been emerged to build Web applications. These approaches can be very different, but they have some elements in common. Of course, reality is more complex than this summary. For example, I do not consider React Context API. However, I am not going to make a detailed comparison among different frameworks.</p><h2 id="component-rendering-unit-bindings-lifecycle">Component = rendering unit + bindings + lifecycle</h2><p>Components are the main unit. They define how to render a bit of user interface (view) from a state and bind dom events and elements (in a Babel of different syntaxes and semantics). Usually, components have a life-cycle (e.g. mount, destroy), can be composed and allow some form of child-parent communication (e.g. props, events).</p><h2 id="views-are-defined-in-a-declarative-way">Views are defined in a declarative way</h2><p>Views are usually defined in a declarative way. Programmers do not have to take care about how a page is rendered; this is different from previous approaches (e.g. Backbone) where programmers had to implement the actual rendering algorithm. There are at least two declarative approaches. The first one is based on templating languages that extend HTML syntax (e.g. handlebars) with some control statements (e.g. if, for each). In the other approach, views are defined in a native language with some primitives or functions to represent HTML tags (e.g. JSX is Javascript extended with HTML-like tags).</p><h2 id="inter-component-communication">Inter-component communication</h2><p>Historically, components lacked tools for complex inter-component communication. For this reason, several paradigms have popped up. For example, <a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="noopener">Flux</a> is a design pattern used in many libraries, e.g. Redux. Basically, an application has a global state as a unique source of truth. Individual components map the state to views and interact with the global state sending actions/events that mutate the original state.</p><h1 id="a-more-abstract-approach">A more abstract approach</h1><p>I want to adopt a more abstract point of view independent from the actual implementation.</p><p>First, I want to represent views with a high level data structure. For example, a view is a tree, which is part of a bigger tree we call dom; I do not care if this tree is described using templates or JSX or pure functions, how elements are bound to state or which particular algorithm I use to update the actual dom in my browser.</p><p>Then I want to abstract away from the underlying communication mechanisms and architectures. We want to describe what changes (e.g. data dependencies), not how (e.g. actions and mutations).</p><p>Finally, dom and state must be separated and, above all, independent.</p><p>The last point is inspired by bigraph theory [1]. Bigraphs are a formalism to model space and motion. I wrote a short introduction <a href="https://mstn.github.io/2018/09/08/milner-bigraphs-matrices/">here</a>. The underlying insight is that space and motion should be modeled by independent data structures.</p><p>In an analogous way, we might think of a web application as a spatial part (dom) plus a dynamic part (communication). These parts are logically independent. For example, I should be able to click on an &quot;add to basket&quot; button and see the navbar basket updated regardless on where the button and the basket are located in the user interface.</p><p>As a consequence, we do not need any special device for child-parent comunication. There is only one uniform communication mechanism independent from the dom hierarchy.</p><p>Another aspect is state. In modern web development state is seen with suspect. We are told to avoid side effects and there are good reasons to follow this generic advice. However, I think, the problem is not state in itself, rather, the lack of compositionality of states. React and Vue are good tools to compose user interfaces (i.e. doms), but, in my opinion, they lack compositionality mechanisms for state (maybe Context API could change this).</p><p>In the rest of this post, I will sketch an operational semantics and I will borrow several ideas from the operational semantics for signal flow graphs [2]. Please bear in mind that many important details are omitted and I am not giving a full working set of operational rules. All of this is very work in progress. My main goal is to communicate the informal intuition to the average programmer who does not know anything about operational semantics and category theory.</p><h1 id="abstract-dom">Abstract dom</h1><p>An abstract dom is a representation of possible dom states. We prefer the term abstract dom, because virtual dom is quite overloaded at the moment.</p><p>An abstract dom is defined by three elements,</p><ul><li>Nodes</li><li>IF Nodes</li><li>EACH Nodes</li></ul><p>Nodes are standard and custom dom element such as <code>div</code>, <code>span</code> and so forth. IFs and EACHs are control nodes for conditional and iterative rendering, respectively.</p><p>In other words, an abstract dom is a dom with some extra features. We could add recursion and other fancy stuff to the list of extra features, but, for now, we prefer to keep it simple. In practice, we define templates or jsx with IFs and EACHs. Rarely, we need more power. However, this is not a good reason to not add more power.</p><p>A node has some ports and an inner state. Ports are like arguments of a function (even if their relation is not necessarily functional). Inner state is the state of the node. For example, a button can be <code>pressed</code> or <code>unpressed</code> or an <code>li</code> element can be parameterized by its position <span class="math inline">\(i\)</span> within a list.</p><p>The behavior of individual nodes is defined by a set of rules. A rule is a labelled transition of the form <span class="math inline">\(t \overset{l}{\rightarrow} t&#39;\)</span> where <span class="math inline">\(t\)</span> is the redex, <span class="math inline">\(t&#39;\)</span> is the reductum and <span class="math inline">\(l\)</span> is a label.</p><p>For example, consider we want to define the behavior of a button. In the picture below we define a node for the button element and two rules that simulate the click event in HTML.</p><div class="figure"><img src="/images/web/rules-for-button-and-composition.png"></div><p>A button is represented as a box with the name of the tag (i.e. <code>button</code>) and an inner state (i.e. <code>pressed</code> or <code>unpressed</code>). A button has two ports. Intuitively, one listens to dom events while the other is an event handler. We label ports with numbers in order to distinguish them.</p><p>A transition label is not a single symbol, but a set of symbols corresponding to the possible values on ports. Instead of adding labels on the top of arrows, we put labels on redexes. Not all ports must have a value in a transition and the assignment is not necessarily functional nor deterministic.</p><p>The first rule <code>R_BTN_CLICK</code> says that, if a button is <code>unpressed</code>, when it gets a click event on port 2, then it changes its state to <code>pressed</code>.</p><p>Instead, if the button is already <code>pressed</code> and port 2 does not have any click event (e.g. user has released the button), then the button state gets <code>unpressed</code> again and a 1 is emitted on port 1. This is rule <code>R_BTN_RELEASED</code>.</p><p>As for bigraphs, nodes can be nested. On the right hand side of the picture above, our button is inserted into a <code>div</code> element and has a sibling <code>span</code> node. Note that port links are independent on the dom hierarchy and cross the boundaries of the parent element.</p><p>Control nodes are like dom nodes but with special rules. Let's start with IF.</p><div class="figure"><img src="/images/web/if-rule.png"></div><p>On the right, we represent the IF node while the two IF rules are on the left. A IF node is a box (we use thicker borders to denote control nodes), with a port (the IF condition) and two holes. As we will see later, every node can have holes that can be filled by other nodes (again, this is from bigraph theory). We use dashed boxes to denote not active areas. Intuitively, a sub-tree within a dashed box is not displayed and its connections are not active. In the case of IF nodes, hole 0 is the &quot;then&quot; branch while hole 1 is the &quot;else&quot; branch. The two rules are called <code>R_IF_FALSE</code> and <code>R_IF_TRUE</code>, respectively, and are fairly trivial.</p><h1 id="state">State</h1><p>We denote a state as a node with some ports and a value. State ports have a different color (i.e. red) because we want nodes communication to be mediated by state. In other words, we do not want to connect two dom nodes directly. However, I am not sure about this choice (which is influenced by the use of edges in bigraphs) and it could change in the future.</p><p>A state is not just a value container. It is a value plus some rules to mutate this value. For example, the following picture shows some examples of state and state rules.</p><div class="figure"><img src="/images/web/state-examples.png"></div><p>Rules can leave the state unchanged like in <code>lt</code> (<code>R_LT2_TRUE</code> and <code>R_LT2_FALSE</code>) or <code>filter</code> (<code>R_FILTER</code>) or change the state like in <code>inc</code> (<code>R_INC</code>). <code>R_INC</code> increases the stored state by one. <code>R_LT2_TRUE</code> and <code>R_LT2_FALSE</code> check if a value is less than 2 and return <code>true</code> or <code>false</code>, respectively. <code>R_FILTER</code> allows only some values to pass, in this case, only values equals to the state.</p><h1 id="a-counter-example">A counter example</h1><p>Now we are going to put together the building blocks described in previous section. We are going to build a simple counter that shows the number of button clicks and, if this number is greater than or equal to 2, the counter explodes.</p><h2 id="the-counter">The Counter</h2><div class="figure"><img src="/images/web/counter.png"></div><p>The picture above represents our counter. We need two states for increasing the counter value and checking if the count has breached the threshold. Box nesting resembles the structure of the HTML page very closely.</p><h2 id="first-click-on-button">First click on button</h2><div class="figure"><img src="/images/web/counter-steps-1-2.png"></div><p>Here, we show the transitions triggered when user clicks on the button once. The first transition is the application of the rule <code>R_BTN_CLICK</code>: when user clicks, the button state is changed to <code>pressed</code> and that is it. Here and in what follows, we mark red the parts changed in a transition.</p><p>The second transition is more interesting. When button has state <code>pressed</code>, the only possible rule we might possibly apply is <code>R_BTN_RELEASED</code>. However, we need to check if we can apply this rule in a consistent way with other rules. In particular, button port <code>1</code> (right-bottom) has label <code>1</code>. This label is shared with <code>inc</code> state and <code>R_BTN_RELEASED</code> can be applied only if we can apply a rule for <code>inc</code> where port label is also <code>1</code>.</p><p>In this case, the rule is <code>R_INC</code> and we can follow the same reasoning for <code>lt2</code> and apply rule <code>R_LT2_TRUE</code>.</p><p>Again, this is just the basic idea. Several details must be clarified or fixed. We would like define a composition mechanism for individual rules with a sort of operational semantics in the fashion of [2].</p><h2 id="second-click-on-button">Second click on button</h2><div class="figure"><img src="/images/web/counter-steps-3-4.png"></div><p>Then user can click on button once more. The first transition is the same as before. The second transition triggers <code>R_IF_FALSE</code>. So abstract dom changes, the <code>then</code>-branch is disabled and the text <code>BUM!</code> is displayed.</p><p>Note that here we are overlooking several important details. For example, we should specify better what we mean when a dom region is disabled and how the corresponding &quot;links&quot; can be disabled, too (e.g. it should not be possible to click on the button again).</p><h1 id="coming-soon">Coming soon</h1><p>In some next post, we will add more details. In particular, I want to show:</p><ul><li>Each rules: some nodes can be rendered iteratively and dynamically. Think about <code>li</code> elements in a <code>ul</code> list.</li><li>Composition: states and doms can be glued together. Building blocks are components, a mix of doms and states.</li><li>A TODO app: a more complex example to show how to build something real (or almost real).</li></ul><h1 id="credits">Credits</h1><p>Diagrams in this post are created using <a href="https://www.mathcha.io" target="_blank" rel="noopener">Mathcha</a>.</p><h1 id="references">References</h1><p>[1] Robin Milner. The space and motion of communicating agents. Cambridge University Press, 2009.</p><p>[2] F. Bonchi, P. Sobocinski, and F. Zanasi. Full abstraction for signal flow graphs. ACM SIGPLAN Notices. Vol. 50. No. 1. ACM, 2015.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In this post I want to talk about a language for representing user interfaces and their dynamics. At the moment, the language is only ske
      
    
    </summary>
    
    
      <category term="react" scheme="http://mstn.github.io/tags/react/"/>
    
      <category term="web" scheme="http://mstn.github.io/tags/web/"/>
    
      <category term="vue" scheme="http://mstn.github.io/tags/vue/"/>
    
      <category term="bigraphs" scheme="http://mstn.github.io/tags/bigraphs/"/>
    
      <category term="signal flow graphs" scheme="http://mstn.github.io/tags/signal-flow-graphs/"/>
    
      <category term="category theory" scheme="http://mstn.github.io/tags/category-theory/"/>
    
  </entry>
  
  <entry>
    <title>Matrix calculus for Milner&#39;s Bigraphs</title>
    <link href="http://mstn.github.io/2018/09/08/milner-bigraphs-matrices/"/>
    <id>http://mstn.github.io/2018/09/08/milner-bigraphs-matrices/</id>
    <published>2018-09-08T07:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.575Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This post is still draft and made public &quot;as is&quot; without any revision and any claim about its correctness and completeness. You can track changes and amends in <a href="https://github.com/mstn/mstn.github.io" target="_blank" rel="noopener">git log</a>.</p></blockquote><blockquote><p>If you spot any mistake or you want to discuss anything, feel free to drop me a line at mstn@posteo.org.</p></blockquote><p>This is the first of (maybe) a series of posts about Applied Category Theory [2]. It is more a personal exercise to &quot;learn by doing&quot; than something to be taken seriously. As a case study, I chose bigraphs: my tentative program is to apply some interesting concepts illustrated in [2] in this particular case.</p><p>Bigraphs [1] are a formalism invented by Robin Milner to model space and communicating agents. Milner is more famous for <a href="https://en.wikipedia.org/wiki/Robin_Milner" target="_blank" rel="noopener">other breakthroughs</a> in theoretical computer science, such as <span class="math inline">\(\pi\)</span>-calculus and ML programming language. He was working on bigraphs at the end of his career, but we find similar ideas even in some of his early works. My source about bigraphs is [1]. You can find the same content in Milner's original papers available online for free.</p><p>Circuit-like diagrams can be represented as matrices, see for example [2]. Here, we want to explore a matrix calculus that could be seen as a generalization of bigraphs.</p><p>While in [2] matrices are used to describe relations between inputs and outputs, here matrices are a sort of dependency graph.</p><p>Probably, the connection between bigraph and matrix calculus is already known, even if I have not found anything on the Web. Anyway, it is interesting enough to write a blog post about it.</p><p>In [2] (I have not read it, I have only read the short summary on Wikipedia) a generalization of bigraphs is proposed where spatial relations are modeled with a relation instead of a function as in Milner. A matrix can represent a sort of relation between rows and columns. Hence, it could be similar to what I am describing here.</p><p>In this post I will introduce bigraphs and their interpretation as matrices in a quite informal way. Hopefully, if I find time, I will focus on Category Theory in next posts.</p><h2 id="informal-introduction">Informal introduction</h2><p>The following picture taken from [1] (p.13) is an example of bigraph.</p><div class="figure"><img src="/images/bigraphs/bigraph-anatomy.png"></div><p>The component of a bigraphs are:</p><ul><li>Vertices <span class="math inline">\(v_0, v_1, v_2, \ldots\)</span>. Vertices are interpreted as ambients and form a hierarchy (i.e. &quot;within&quot; relation).</li><li>Vertices have ports (black dots) and ports are connected through edges <span class="math inline">\(e_0, e_1, \ldots\)</span>. Edges are communication channels. Edges can cross boundaries.</li><li>Roots <span class="math inline">\(0, 1, \ldots\)</span> and sites <span class="math inline">\(0, 1, \ldots\)</span> are outer and inner ambients, respectively. A site is a hole that can be filled with the root of another bigraph.</li><li>Outer names <span class="math inline">\(y_0, y_1, y_2, \ldots\)</span> and inner names <span class="math inline">\(x_0, x_1, \ldots\)</span> are interfaces to connect ports to an external context and edges to internal ports.</li></ul><p>The main insight behind bigraphs is that space and communication are independent. For example, I need to be in a particular room to get wifi access, but, when I send an email, the communication is independent (at the application level) from the spatial configuration of the building where I am.</p><p>Hence, we can think of bigraphs as two independent data structures. For example, the bigraph above can be split into its constituent parts as in the following picture.</p><div class="figure"><img src="/images/bigraphs/place-and-link-graphs.png"></div><p>The two different data structures are called place graph and link graph, respectively. Place graphs describe physical structure whereas link graphs represent communication between agents (i.e. links are communication channels). Space and communication are independent, or orthogonal in Milner's lingo.</p><p>Bigraphs can be composed through their interfaces (roots/sites, inner/outer names). Composition is defined for link graphs and place graphs, separately and independently.</p><p>That is it! You can find more examples in [1]. In the rest of this blog post I am going to formalize a generalization of the intuitive notion of bigraphs in terms of matrices and their operations.</p><h2 id="matrices">Matrices</h2><p>Notation. For <span class="math inline">\(m \in \mathbb{N_{\geq 0}}\)</span>, <span class="math inline">\(\underline{m}\)</span> is the set <span class="math inline">\(\{1, \ldots, m\}\)</span> and <span class="math inline">\(\underline{0} = \emptyset\)</span>.</p><p>An <span class="math inline">\((m, n, R)\)</span> matrix <span class="math inline">\(M\)</span> is a function <span class="math inline">\(M: \underline{m} \times \underline{n} \to R\)</span>. We say <span class="math inline">\(M\)</span> ranges over <span class="math inline">\(\underline{m}\)</span> and <span class="math inline">\(\underline{n}\)</span> and has values in a rig <span class="math inline">\(R\)</span>. We define <span class="math inline">\(\mathit{size} \; M\)</span> as <span class="math inline">\(m \times n\)</span>. We write <span class="math inline">\(M: m \to n\)</span> and omit <span class="math inline">\(R\)</span> when it is clear from the context. Definitions from [2].</p><p>Given a matrix <span class="math inline">\(M: m \to n\)</span>, <span class="math inline">\(I \subseteq \underline{m}\)</span> and <span class="math inline">\(J \subseteq \underline{n}\)</span>, <span class="math inline">\(M_I^J\)</span> is the submatrix of <span class="math inline">\(M\)</span> formed by <span class="math inline">\(I\)</span> rows and <span class="math inline">\(J\)</span> columns. We write just <span class="math inline">\(M_I\)</span> or <span class="math inline">\(M^J\)</span> if <span class="math inline">\(J = \underline{n}\)</span> or <span class="math inline">\(I = \underline{m}\)</span>, respectively. For <span class="math inline">\(i \leq m, j \leq n\)</span>, <span class="math inline">\(M_i\)</span> and <span class="math inline">\(M_j\)</span> are the <span class="math inline">\(i\)</span>-th row and the <span class="math inline">\(j\)</span>-th column of <span class="math inline">\(M\)</span>. <span class="math inline">\(M_{\emptyset} = M^{\emptyset}\)</span> is the empty matrix.</p><h2 id="matrices-1"><span class="math inline">\(2\)</span>-matrices</h2><p>We denote <span class="math inline">\(2\)</span> the rig <span class="math inline">\((\{ 0, 1 \}, \cdot, +)\)</span> where <span class="math inline">\(\cdot\)</span> is logical AND and <span class="math inline">\(+\)</span> is logical OR. In this post we will deal only with <span class="math inline">\(2\)</span>-matrices, but some generalizations are still possible (e.g. stochastic matrices whose entries are probabilities).</p><p>Let <span class="math inline">\(M: m \to n\)</span> and <span class="math inline">\(i=1 \ldots m\)</span>, then the support of <span class="math inline">\(M_i\)</span> is</p><p><span class="math display">\[S_i(M) = \{ M(i,j) \; | \; \exists j = 1 \ldots n-1 \; M(i,j)=1 \}\]</span></p><p>A <span class="math inline">\(2\)</span>-matrix <span class="math inline">\(M: m \to n\)</span> is <strong>functional</strong> if <span class="math inline">\(\sum S_i(M) \leq 1\)</span> for every row <span class="math inline">\(i\)</span>. It is <strong>lean</strong> if the row sum is exactly <span class="math inline">\(1\)</span>.</p><p>A <span class="math inline">\(2\)</span>-matrix <span class="math inline">\(M: m \to n\)</span> is <strong>acyclic</strong> if and only if <span class="math inline">\(M + I\)</span> is a <span class="math inline">\(2\)</span>-matrix with all eigenvalues positive, where <span class="math inline">\(I\)</span> is the identity matrix (from <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener">Wikipedia</a>).</p><h2 id="partial-product">Partial product</h2><p>Given <span class="math inline">\(M: m \to n\)</span> and <span class="math inline">\(N: k \to l\)</span> over a rig <span class="math inline">\(R\)</span>, <span class="math inline">\(0 \leq i \leq n, k\)</span> and <span class="math inline">\(\cdot\)</span> classical matrix product, the partial product <span class="math inline">\(\cdot_{i}\)</span> of <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span> is a <span class="math inline">\(m + (k-i) \times (n - i) + l\)</span> matrix <span class="math inline">\(M \cdot_{i} N\)</span> with this form:</p><p><span class="math display">\[M \cdot_{i} N = \begin{array}{cc} \begin{array}{cc} \underline{l} &amp; \quad l + \underline{n-i} \end{array}\\  \left(\begin{array}{cc}    M^{\underline{i}} \cdot N_{\underline{i}} &amp; M^{\underline{n} \setminus \underline{i}} \\    N_{\underline{k} \setminus \underline{i}} &amp; 0  \end{array}\right) &amp;  \begin{array}{c} \underline{m} \\ m + \underline{k-i} \end{array} \end{array}\]</span></p><p>If <span class="math inline">\(i=n=k\)</span>, partial product is the usual matrix product. Instead, if <span class="math inline">\(i = 0\)</span>, partial product is the tensor product.</p><h2 id="forests-and-trees">Forests and trees</h2><p>A <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)" target="_blank" rel="noopener">forest</a> <span class="math inline">\(F\)</span> is an undirected acyclic graph <span class="math inline">\((V, E)\)</span> where <span class="math inline">\(V\)</span> and <span class="math inline">\(E\)</span> are finite sets. When a forest is also connected is a tree.</p><p>An <span class="math inline">\((R,S)\)</span>-forest <span class="math inline">\((V, E)\)</span> is a forest whose vertex set <span class="math inline">\(V\)</span> is the disjoint union <span class="math inline">\(R \uplus S \uplus U\)</span>, where <span class="math inline">\(R\)</span> are roots, <span class="math inline">\(S\)</span> sites and <span class="math inline">\(U\)</span> internal nodes. Roots and sites represent internal and external interfaces, respectively. Intuitively, <span class="math inline">\((R,S)\)</span>-forests can be composed gluing together their sites and roots.</p><p>We label roots and sites with ordinals <span class="math inline">\(0, 1, \ldots\)</span> and inner nodes with <span class="math inline">\(v, u, \dots\)</span>.</p><p>Note that, in order to stick to Milner's terminology we are using the world &quot;root&quot; in an improper way. In classical graph theory a tree can have zero, one or more roots. In our case an inner node can be a root in the sense of classical graph theory, but it is not an interface root in our definition. In practice there should be no confusion.</p><p>In the Figure 1, <span class="math inline">\(F\)</span> is a forest where <span class="math inline">\(u_0\)</span> is a inner node, roots are <span class="math inline">\(\{0, 1\}\)</span> and sites are <span class="math inline">\(\{0, 1\}\)</span>. The forest is made of two trees, namely two non connected subgraphs. On the right, we see the result of composing <span class="math inline">\(G\)</span> and <span class="math inline">\(F\)</span> together: <span class="math inline">\(F\)</span>'s roots are glued with <span class="math inline">\(G\)</span>'s sites sharing the same name.</p><div class="figure"><img src="/images/bigraphs/compose-trees.png" alt="Figure 1. Open forests and their composition"><p class="caption"><strong>Figure 1.</strong> Open forests and their composition</p></div><p>Let us assume vertices can be enumerated, i.e. we uniquely assign a column/row index to each vertex. We carefully abuse the notation here. For example we write <span class="math inline">\(M(x,y)\)</span> for labels <span class="math inline">\(x, y\)</span> instead of using the indices associated to <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. We will see in a next post how to formalize that a bit better, but for now we want to explain the basic idea without too obfuscating formal notation.</p><p>An <span class="math inline">\((R,S)\)</span>-forest <span class="math inline">\(F = (R \uplus S \uplus U, E)\)</span> can be represented as a <span class="math inline">\(2\)</span>-matrix <span class="math inline">\(M: |S \uplus U| \to |R \uplus U|\)</span> built in this way.</p><ol style="list-style-type: decimal"><li>Assign <span class="math inline">\(S\)</span> sites to rows <span class="math inline">\(\underline{|S|}\)</span> and <span class="math inline">\(U\)</span> inner nodes to rows <span class="math inline">\(|S|+\underline{|U|}\)</span>,</li><li>Assign <span class="math inline">\(R\)</span> roots to columns <span class="math inline">\(\underline{|R|}\)</span> and <span class="math inline">\(U\)</span> inner nodes to columns <span class="math inline">\(|R|+\underline{|U|}\)</span>,</li><li><span class="math inline">\(M(x,y) = (y, x) \in E\)</span>, i.e. <span class="math inline">\(y\)</span> is the parent of <span class="math inline">\(x\)</span>.</li></ol><p>Basically, <span class="math inline">\(M\)</span> is the <a href="https://en.wikipedia.org/wiki/Adjacency_matrix" target="_blank" rel="noopener">adjacency matrix</a> of the forest. We denote <span class="math inline">\([F]\)</span> the matrix corresponding to a forest <span class="math inline">\(F\)</span>.</p><p>Graphs <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> in Figure 1 can be represented as two matrices <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span>, respectively.</p><p><span class="math display">\[M = \begin{array}{cc} \begin{array}{ccc} 0 \quad 1 \quad u_0 \end{array}\\  \left(\begin{array}{cc|c}    0 &amp; 0 &amp; 1 \\    0 &amp; 1 &amp; 0 \\    1 &amp; 0 &amp; 0   \end{array}\right) &amp;  \begin{array}{c} 0 \\ 1 \\ u_0 \end{array} \end{array}\]</span></p><p><span class="math display">\[N = \begin{array}{cc} \begin{array}{ccccc} 0 \quad v_0 \quad v_1 \quad v_2 \quad v_3 \end{array}\\  \left(\begin{array}{ccccc}    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\    \hline    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\  \end{array}\right) &amp;  \begin{array}{c} 0 \\ 1 \\ v_0 \\ v_1 \\ v_2 \\ v_3 \end{array} \end{array}\]</span></p><p>Given an <span class="math inline">\((R,S)\)</span>-forest <span class="math inline">\(G\)</span> and an <span class="math inline">\((S,T)\)</span>-forest <span class="math inline">\(F\)</span>, composition <span class="math inline">\(G \circ F\)</span> is defined as <span class="math inline">\([F] \cdot_{|S|} [G]\)</span>. If there are no inner nodes, composition boils down to classical matrix multiplication.</p><p>In our example <span class="math inline">\(S=\{0, 1 \}\)</span> and <span class="math inline">\(i=2\)</span>, we have separated with a line the two sub-matrices <span class="math inline">\(M^{\underline{i}}\)</span> and <span class="math inline">\(N_{\underline{i}}\)</span> induced by <span class="math inline">\(S\)</span>. The partial product <span class="math inline">\(M \cdot_i N\)</span> is the following matrix.</p><p><span class="math display">\[M \cdot_i N = \begin{array}{cc} \begin{array}{ccccc} 0 \quad v_0 \quad v_1 \quad v_2 \quad v_3 \quad u_0 \end{array}\\  \left(\begin{array}{ccccc|c}    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\    \hline    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\  \end{array}\right) &amp;  \begin{array}{c} 0 \\ 1 \\ u_0 \\ v_0 \\ v_1 \\ v_2 \\ v_3 \end{array} \end{array}\]</span></p><p>We have separated the four sub-matrices of the definition above with vertical and horizontal lines. It is easy to verify that the matrix corresponds to the composition of the two trees of this example.</p><p>In Milner, tensor product is defined if interfaces are disjoint. We define tensor product always up to renaming of interfaces (i.e. disjoint sum of names). Given an <span class="math inline">\((R,S)\)</span>-forest <span class="math inline">\(G\)</span> and an <span class="math inline">\((T, V)\)</span>-forest <span class="math inline">\(F\)</span>, the tensor product <span class="math inline">\(G \otimes F\)</span> is a <span class="math inline">\((R+T, S+V)\)</span>-forest whose matrix <span class="math inline">\([G \otimes F]\)</span> is <span class="math inline">\([F] \circ_\emptyset [G]\)</span>.</p><p>It is not hard to see that <span class="math inline">\(\cdot_\emptyset\)</span> is the matricial tensor product and it is equivalent to the juxtaposition of two trees (e.g. parallel composition).</p><p>Not every matrix is a forest, of course. In order to enforce that we need to require two additional properties on <span class="math inline">\(M\)</span>:</p><ol style="list-style-type: decimal"><li><span class="math inline">\(M\)</span> is functional,</li><li><span class="math inline">\(M^{N}_{N}\)</span> is acyclic.</li></ol><h2 id="port-graphs">Port graphs</h2><p>Partial product applies to matrices in general. So we can model more generic data structure relaxing the acyclic condition that defines trees and forests. This leads us to the example of port graphs.</p><p>Port graphs are graphs whose vertices have ports and edges connect different ports. Formally, an <span class="math inline">\((X, Y)\)</span>-port graph <span class="math inline">\(G\)</span> is <span class="math inline">\((V, E, \mathit{ctrl}, \mathit{link})\)</span> where <span class="math inline">\(V\)</span> is a set of vertices, <span class="math inline">\(E\)</span> a set of edges, <span class="math inline">\(\mathit{ctrl}: V \to \mathbb{N}\)</span> and <span class="math inline">\(\mathit{link}: X \cup P \to Y \cup E\)</span> where <span class="math inline">\(P=\{ (v, i) \;|\; v \in V \wedge i \in \underline{\mathit{ctrl}(v)} \}\)</span>.</p><p>An <span class="math inline">\((X, Y)\)</span>-port graph <span class="math inline">\(G\)</span> can be represented as a functional matrix <span class="math inline">\(L: |X \uplus P| \to |Y \uplus E|\)</span> built in this way.</p><ol style="list-style-type: decimal"><li>Assign <span class="math inline">\(X\)</span> inner names to rows <span class="math inline">\(\underline{|X|}\)</span> and <span class="math inline">\(P\)</span> ports to rows <span class="math inline">\(|X|+\underline{|P|}\)</span>,</li><li>Assign <span class="math inline">\(Y\)</span> outer names to columns <span class="math inline">\(\underline{|Y|}\)</span> and <span class="math inline">\(E\)</span> edges to columns <span class="math inline">\(|Y|+\underline{|E|}\)</span>,</li><li><span class="math inline">\(L(x, y) = 1\)</span> if and only if <span class="math inline">\(\mathit{link}(x) = y\)</span>.</li></ol><p>We can compose port graphs by product as we did for forests.</p><div class="figure"><img src="/images/bigraphs/link-graphs-compos.png" alt="Figure 2. Composition of port graphs"><p class="caption"><strong>Figure 2.</strong> Composition of port graphs</p></div><p>Composition of port graphs is the partial product of their respective matrices.</p><h2 id="partial-sum">Partial sum</h2><p>Partial product preserves acyclic and functional properties of matrices. Now we define partial sum where functionality is not preserved. Partial sum is a generalization of Milner's parallel product. Note that Milner's parallel product preserves functionality.</p><p>We define sum on sub-matrices. Let <span class="math inline">\(M: m \to n\)</span> and <span class="math inline">\(N: k \to l\)</span> be two matrices and <span class="math inline">\(i \leq m, k\)</span> and <span class="math inline">\(j \leq n, j\)</span>, then the partial sum <span class="math inline">\(+_i^j\)</span> of <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span> is a <span class="math inline">\(m+k-i \times n+l-j\)</span> matrix <span class="math inline">\(M +_i^j N\)</span> of this form:</p><p><span class="math display">\[M +_i^j N = \begin{array}{cc} \begin{array}{ccc} \underline{j} &amp; \quad \underline{n} \setminus j \quad \underline{l} \setminus j \end{array}\\  \left(\begin{array}{ccc}    M_{\underline{i}}^{\underline{j}} + N_{\underline{i}}^{\underline{j}} &amp; M_{\underline{i}}^{\underline{n} \setminus j} &amp; N_{\underline{i}}^{\underline{l} \setminus j} \\    M_{\underline{m}-i}^{j} &amp; M_{\underline{n} \setminus i}^{\underline{n} \setminus j} &amp; 0 \\    N_{\underline{n} \setminus i}^{\underline{j}} &amp; 0 &amp; N_{\underline{k} \setminus i}^{\underline{l} \setminus j}  \end{array}\right) &amp;  \begin{array}{c} \underline{i} \\ \underline{m} \setminus i  \\ \underline{k} \setminus i \end{array} \end{array}\]</span></p><p>If <span class="math inline">\(i = j = 0\)</span>, then <span class="math inline">\(+_i^j\)</span> is the tensor product. If <span class="math inline">\(i=m=k\)</span> and <span class="math inline">\(j=n=l\)</span>, partial sum is the classical matrix sum operation.</p><p>The definition above remembers Milner's definition of parallel product when <span class="math inline">\(M_{\underline{i}}^{\underline{j}} = N_{\underline{i}}^{\underline{j}}\)</span>.</p><p>If <span class="math inline">\(M: m \to n\)</span> and <span class="math inline">\(N: k \to l\)</span> are two matrices, there are four ways (up to isomorphism?) to compose them: <span class="math inline">\(M \cdot_i N\)</span>, <span class="math inline">\(M \cdot_i N\)</span>, <span class="math inline">\(M +_i^0 N\)</span> (<span class="math inline">\(N +_i^0 M\)</span>) and <span class="math inline">\(M +_0^i N\)</span> (<span class="math inline">\(N +_0^i M\)</span>) for some proper <span class="math inline">\(i\)</span>. The four ways are equivalent and correspond to tensor product when <span class="math inline">\(i=0\)</span>. If we think in terms of interfaces from the examples above, the four ways are equivalent when interfaces are fully disjoint.</p><h2 id="final-notes">Final notes</h2><p>Place graphs and link graphs are (surprise, surprise!) special cases of forests and port graphs, respectively.</p><p>The underlying matrix for place graphs is functional and cyclic whereas for link graphs is only functional. We can relax both conditions and define an algebra on generic matrices.</p><p>Link graph interfaces are finite set of names and not ordinals. In theory, ordinals and finite sets of names are the same (i.e. isomorphic). However, in practice, it might be convenient to have finite sets of names instead of anonymous numbers. As it is discussed in the Appendix of [1], we can define parallel composition with name sharing. From a categorical view point, this means that the wanted symmetry is achieved without cumbersome switch morphisms, which sounds lovely.</p><p>So, what if we want to replace ordinals with finite sets?</p><p>We could extend the definition of matrix with named columns and rows. For example, an <span class="math inline">\((X, Y, R)\)</span> matrix <span class="math inline">\(M\)</span> is a function <span class="math inline">\(M: X \times Y \to R\)</span>. We say <span class="math inline">\(M\)</span> ranges over finite sets <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> and has values in some rig <span class="math inline">\(R\)</span>. We define <span class="math inline">\(\mathit{size} \; M\)</span> as <span class="math inline">\(|X| \times |Y|\)</span>.</p><p>Partial product and sum are more or less defined as above. We should pay attention to name clashing, though. So we need to define disjoint union of name sets. I do not find this approach convincing, since it makes the notation heavier. So what I will try next is the keep bare matrices as &quot;semantic&quot; referents and build the mapping between names and ordinals on the top of that.</p><h2 id="references">References</h2><p>[1] Robin Milner. The space and motion of communicating agents. Cambridge University Press, 2009.</p><p>[2] Brendan Fong and David I. Spivak. &quot;Seven Sketches in Compositionality: An Invitation to Applied Category Theory.&quot; arXiv preprint arXiv:1803.05316 (2018).</p><p>[3] Michele Sevegnani and Muffy Calder. &quot;Bigraphs with sharing.&quot; Theoretical Computer Science 577 (2015): 43-73.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;This post is still draft and made public &amp;quot;as is&amp;quot; without any revision and any claim about its correctness and comp
      
    
    </summary>
    
    
      <category term="bigraphs" scheme="http://mstn.github.io/tags/bigraphs/"/>
    
      <category term="milner" scheme="http://mstn.github.io/tags/milner/"/>
    
      <category term="matrices" scheme="http://mstn.github.io/tags/matrices/"/>
    
      <category term="applied category theory" scheme="http://mstn.github.io/tags/applied-category-theory/"/>
    
  </entry>
  
  <entry>
    <title>Weekly digest (week 27-2018)</title>
    <link href="http://mstn.github.io/2018/07/06/weekly-digest-272018/"/>
    <id>http://mstn.github.io/2018/07/06/weekly-digest-272018/</id>
    <published>2018-07-06T07:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.579Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.lowtechmagazine.com/2013/12/high-speed-trains-are-killing-the-european-railway-network.html" target="_blank" rel="noopener">High Speed Trains are killing the European railway network</a> (2013). The author shows that saved travelling time is not much compared to increased ticket prices. In addition, even if trains are actually a more sustainable alternative to air traffic, the high cost of high speed train tickets forced more people to choose cheap but polluting flights over trains. Hence, the overall effect of high speed trains on the environment is negative. Wu Ming 1 from <a href="https://en.wikipedia.org/wiki/Wu_Ming" target="_blank" rel="noopener">Wu Ming collective</a> <a href="https://www.amazon.it/viaggio-promettiamo-breve-Venticinque-lotte/dp/8806225642/" target="_blank" rel="noopener">wrote</a> an interesting book about the fights agaist high speed trains in Val di Susa (in Italian).</li><li><a href="https://code.fb.com/android/profilo-understanding-app-performance-in-the-wild/" target="_blank" rel="noopener">Understanding app performances in the wild</a>. Facebook has released Profilo, an a high-throughput, mobile-first performance tracing library. This tool allows developers to collect and analyse production performance traces. Profilo is available only for Android, at least for now.</li><li><p><a href="https://medium.com/netflix-techblog/lessons-from-building-observability-tools-at-netflix-7cfafed6ab17" target="_blank" rel="noopener">Lessons from Building Observability Tools at Netflix</a>. Netflix relies on several metrics to measure customers’ experience and to improve their product. Simply storing logs does not scale well and the microservice architecture adopted by Netflix introduces new challenges, too. Here is what Netflix did.</p><ul><li>Logs are kept and processed in memory and persisted only when needed. The bigger the system is, the higher storage costs and query times are. See also <a href="https://medium.com/netflix-techblog/stream-processing-with-mantis-78af913f51a6" target="_blank" rel="noopener">Mantis</a>.</li><li>Microservices produce several distributed streams of logs. In order the get new insights on logs it is important to enrich traces with contextual information &quot;so that multiple traces can be grouped together across services&quot;.</li><li>Traces are not analysed by eye, of course. Metrics analysis should be automatized and alerts should be raised if anomalies are detected. Netflix went beyond trivial threshold alerting and implemented some statistical/machine learning algorithms to analyse metrics trends.</li><li>Log storing and retriving must be fast. Netflix used different databases (Cassandra, Elasticsearch, Hive) depending on the kinds of queries. For example, Elasticsearch is better for queries on different fields while Cassandra is better for queries by ids.</li><li>Logs and analysis are made available to engineers and users through custom user interfaces. It does not make sense to show all logs always because not everybody is able to understand them.</li></ul></li></ul><p>It would interesting to know what they do for limiting the overhead of log collecting on the whole system performances.</p><ul><li><a href="https://brandur.org/graphql" target="_blank" rel="noopener">Living APIs, and the Case for GraphQL</a>. The author says that, despite some interests from the developer community and some big players (e.g. Github), GraphQL isn't spreading very fast. The reason for the author is that &quot;GraphQL’s biggest problem may be that,although it’s better, it’s not 'better enough'&quot; with respect to REST. Then he makes some in depth arguments about why GraphQL is better. Instead, it would be interesting to know why it is not better enough.</li><li>React 16 <a href="https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad" target="_blank" rel="noopener">makes available</a> some performance metrics via browsers <a href="https://www.html5rocks.com/en/tutorials/webperformance/usertiming/" target="_blank" rel="noopener">User Timing API</a>. This will open a lot of possibilities for <a href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="noopener">profiling components</a>. For example, it could be interesting to see performance tools integrated into our CI processes. <a href="https://jobs.zalando.com/tech/blog/loading-time-matters/" target="_blank" rel="noopener">Here</a> is a report from Zalando engineers about their real world experience with performance optimization in React.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lowtechmagazine.com/2013/12/high-speed-trains-are-killing-the-european-railway-network.html&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="performance" scheme="http://mstn.github.io/tags/performance/"/>
    
      <category term="graphql" scheme="http://mstn.github.io/tags/graphql/"/>
    
      <category term="logging" scheme="http://mstn.github.io/tags/logging/"/>
    
      <category term="trains" scheme="http://mstn.github.io/tags/trains/"/>
    
      <category term="react" scheme="http://mstn.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Fixed size arrays in Typescript</title>
    <link href="http://mstn.github.io/2018/06/08/fixed-size-arrays-in-typescript/"/>
    <id>http://mstn.github.io/2018/06/08/fixed-size-arrays-in-typescript/</id>
    <published>2018-06-08T07:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.575Z</updated>
    
    <content type="html"><![CDATA[<p>Dependent types are types whose definition depends on a value (from Wikipedia).</p><p>Typescript does not support dependent types <em>per se</em>. However, literal types, even if they are not actual values, allow us to do some interesting things.</p><p>For instance, a classical introductory example to dependent types involves the definition of arrays of fixed length. It turns out that we can define, with some limitations, a type for arrays of fixed size in Typescript, too.</p><p>Let's see in details what we are going to replicate in Typescript.</p><p>In many modern programming language, it is possible to define arrays whose elements have a given type, let's say strings. In Typescript, we write:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Array</span>&lt;string&gt;;</span><br><span class="line">a = []; <span class="comment">// ok</span></span><br><span class="line">a = [ <span class="string">'a'</span> ]; <span class="comment">// ok</span></span><br><span class="line">a = [ <span class="literal">true</span> ]; <span class="comment">// type error!</span></span><br></pre></td></tr></table></figure><p>Dependent types parametrize type definition by values of another type. In the case of arrays we can define arrays of fixed size, for example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Array</span>&lt;<span class="number">2</span>, string&gt;;</span><br><span class="line">a = [ <span class="string">'a'</span>, <span class="string">'b'</span> ]; <span class="comment">// ok</span></span><br><span class="line">a = [ <span class="string">'a'</span> ]; <span class="comment">// type error!</span></span><br></pre></td></tr></table></figure><p>In the example above, the size of arrays is checked at compile time. This means that, if a program compiles correctly, then we will not have a runtime exception because the size of the array is always what we expect.</p><p>I created an <a href="https://www.npmjs.com/package/fixed-size-array" target="_blank" rel="noopener">npm package</a> with the type definition. It boils down to <a href="https://github.com/mstn/fixed-size-array/" target="_blank" rel="noopener">few lines of code</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type FixedSizeArray&lt;N extends number, T&gt; = N extends <span class="number">0</span> ? never[] : &#123;</span><br><span class="line">    <span class="number">0</span>: T;</span><br><span class="line">    length: N;</span><br><span class="line">&#125; &amp; ReadonlyArray&lt;T&gt;;</span><br></pre></td></tr></table></figure><p>Let's see in details why and when it works.</p><p>First, we use the trick introduced in Typescript 2.7 for fixed size tuples. The <code>length</code> of an array has a numeric literal type. We need it to match tuples of exact size.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d: FixedSizeArray&lt;<span class="number">2</span>, string&gt;;</span><br><span class="line"></span><br><span class="line">d = [ <span class="string">'a'</span>, <span class="string">'b'</span> ]; <span class="comment">// ok</span></span><br><span class="line">d = [ <span class="string">'a'</span> ]; <span class="comment">// type error</span></span><br><span class="line">d = [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ]; <span class="comment">// type error</span></span><br></pre></td></tr></table></figure><p>The intersection with <code>ReadonlyArray&lt;T&gt;</code> is needed to enforce the type of the array elements to be <code>T</code>. In addition, fixed size arrays inherit methods of <code>ReadonlyArray</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = [<span class="string">'a'</span>, <span class="literal">true</span>]; <span class="comment">// type error</span></span><br><span class="line">d = [<span class="literal">true</span>, <span class="string">'a'</span>]; <span class="comment">// type error</span></span><br></pre></td></tr></table></figure><p>We use conditional types (Typescript &gt;=2.8) for handling zero length arrays. In Typescript (&gt;= 2.8) the type of <code>[]</code> is always <code>never[]</code>; so, if <code>N</code> is <code>0</code>, the type must be <code>never[]</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e: FixedSizeArray&lt;<span class="number">0</span>, string&gt;;</span><br><span class="line"></span><br><span class="line">e = []; <span class="comment">// ok</span></span><br><span class="line">e = [ <span class="string">'a'</span> ]; <span class="comment">// type error</span></span><br><span class="line">e = [] <span class="keyword">as</span> string[]; <span class="comment">// type error</span></span><br></pre></td></tr></table></figure><p>Finally, property <code>0</code> is required because we can assign tuples only to tuple-like objects and a tuple-like object must have at least <code>0</code> defined by design (<a href="https://github.com/Microsoft/TypeScript/issues/24680#issuecomment-394616609" target="_blank" rel="noopener">source</a>).</p><p>As pointed out by <span class="citation">@AnyhowStep</span> <a href="https://github.com/Microsoft/TypeScript/issues/24680#issuecomment-394710740" target="_blank" rel="noopener">here</a>, we can see the limitations of this approach when we try to access elements through their indexes.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: FixedSizeArray&lt;<span class="number">2</span>, string&gt;;</span><br><span class="line">a = [ <span class="string">'1'</span>, <span class="string">'2'</span> ]; <span class="comment">// ok</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">'1'</span>; <span class="comment">// ok</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">'2'</span>; <span class="comment">// type error, but it should be ok</span></span><br></pre></td></tr></table></figure><p>Another more complex example showing the same problem with <code>keyof</code> type constructor.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Range&lt;N extends number&gt; = keyof FixedSizeArray&lt;<span class="number">2</span>, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r: Range&lt;<span class="number">2</span>&gt;; <span class="comment">// it is '0' | 'length' | ... (read only array props)</span></span><br><span class="line"></span><br><span class="line">r = <span class="string">'length'</span>;</span><br><span class="line">r = <span class="string">'0'</span>;</span><br><span class="line">r = <span class="string">'1'</span>; <span class="comment">// error! I would not expect an error</span></span><br></pre></td></tr></table></figure><p>A better implementation could use <a href="https://github.com/Microsoft/TypeScript/issues/15480" target="_blank" rel="noopener">range types</a>. At the moment Typescript does not support range types and, as far as I know, range types are not on their roadmap in any near future. However, if we had a <code>range</code> operator similar to <code>keyof</code> operator, we could fix the problem above and simplify the definition with:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FixedSizeArray&lt;U <span class="keyword">extends</span> <span class="built_in">number</span>, T&gt; = &#123;</span><br><span class="line">    [k <span class="keyword">in</span> range(U)]: T;</span><br><span class="line">&#125; &amp; &#123; length: U &#125;;</span><br></pre></td></tr></table></figure><p>Another limitation is that it is not possible to do any arithmetic with numeric literal types in Typescript. Apparently, Typescript developers have found some <a href="https://github.com/Microsoft/TypeScript/issues/8112" target="_blank" rel="noopener">technical problems</a>. It is a pity! With numeric literal type arithmetic we could define, for example, that <code>insert</code> applied to an array of length <code>N</code> will return an array of lenght <code>N+1</code>. Since this is not possible for now, we have to stick to immutable arrays.</p><p>Compared with the full firepower of dependent types, our arrays seem a little thing. Still, having a type for immutable arrays of a given length is a lovely feature to have in many practical cases. For example, in React we could specify the exact number of children a parent can have. Another example is a function that requires two array arguments of the same length.</p><p>I wonder if we can find any hacks for current limitations without introducing new constructs to the language.</p><p>A common criticism to dependent types is that they are quite complex to handle for humble programmers. Hence, I think it is interesting to see which features of dependent types can be expressed or mimicked in a programming language without importing all their complexity.</p><p>It would be interesting to understand if we can prove &quot;theorems&quot; on Typscript programs using its type system in a similar way to what is done in dependent type languages. <a href="https://github.com/tycho01" target="_blank" rel="noopener">Tycho</a> has been developing <a href="https://github.com/tycho01/typical" target="_blank" rel="noopener">an experimental library</a> of type-level operations for TypeScript. I think it could be a good starting point.</p><h2 id="credits">Credits</h2><p>Numeric literals for array length has been used for tuples <a href="https://github.com/Microsoft/TypeScript/pull/17765" target="_blank" rel="noopener">since TS 2.7</a>.</p><p>Type definition had been simplified as suggested <a href="https://github.com/Microsoft/TypeScript/issues/6229#issuecomment-376988681" target="_blank" rel="noopener">here</a> by <span class="citation">@tycho01</span>.</p><p>Daniel explained me better how typing works with tuples <a href="https://github.com/Microsoft/TypeScript/issues/24680#issuecomment-394616609" target="_blank" rel="noopener">here</a>.</p><h2 id="references">References</h2><p>Wikipedia, <a href="https://en.wikipedia.org/wiki/Dependent_type" target="_blank" rel="noopener">Dependent Type</a>, accessed 10/04/2018</p><h2 id="more-resources">More resources</h2><ul><li><a href="https://github.com/mstn/fixed-size-array/" target="_blank" rel="noopener">Source code</a></li><li><a href="https://www.npmjs.com/package/fixed-size-array" target="_blank" rel="noopener">NPM package</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dependent types are types whose definition depends on a value (from Wikipedia).&lt;/p&gt;
&lt;p&gt;Typescript does not support dependent types &lt;em&gt;pe
      
    
    </summary>
    
    
      <category term="typescript" scheme="http://mstn.github.io/tags/typescript/"/>
    
      <category term="dependent types" scheme="http://mstn.github.io/tags/dependent-types/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://mstn.github.io/2018/06/06/hello-world/"/>
    <id>http://mstn.github.io/2018/06/06/hello-world/</id>
    <published>2018-06-06T07:00:00.000Z</published>
    <updated>2019-07-25T09:29:06.575Z</updated>
    
    <content type="html"><![CDATA[<p>Here, I will occasionally blog about my ramblings on tech, math and life.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Here, I will occasionally blog about my ramblings on tech, math and life.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
